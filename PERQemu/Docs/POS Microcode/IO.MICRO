$Title IO.Micro - Perq I/O microcode.
! IO Microcode.
!-----------------------------------------------------------------------------
!
!       IO.Micro - Perq I/O microcode.
!       Brian Rosen      ca. 1 Jan 80.
!       J. P. Strait        14 Feb 81.   Cleaned-up.
!       Copyright (C) Three Rivers Computer Corporation, 1980, 1981.
!
! Abstract:
!   This file provides the IO microcode for the standard PERQ system.
!
!-----------------------------------------------------------------------------

!---------------------------------------------------------------------------
!
! Change History
!
! 29 Jan 82  V1.10 WJHansen
!     Increment DDS during device table initialization
!
! 16 Nov 81  V1.9  Don Scelza (John Strait)
!     Put in John's changes for the MegaByte memory.  VidInt
!
! 28 Sep 81  V1.8  Don Scelza
!     Took useful definitions from IO.Micro and moved them to IO.DFS.
!     Also defined the locations of the IOTLates and IOXLates.
!
! 16 Apr 81  V1.7  George Robertson, Gene Ball
!     Added support for 3MHz Ethernet
!
! 10 Apr 81  V1.6  George Robertson
!     Moved IO to 4400-5777.
!
! 31 Mar 81  V1.5  George Robertson
!     Moved time base from clock to video refresh.
!
!  6 May 81  V1.4  John Strait.
! 1. Rename dskTrack to dskCyl.
! 2. Change the StartIO that tells the microcode what cylinder the heads are
!    on to read the cylinder number from the E-Stack.  This allows recalibrate
!    code to set the current cylinder number to MaxCylinder (201 decimal) 
!    before starting.
! 3. Don't initialize dskCyls in IO initialization--let the Pascal code do it.
!
! 14 Mar 81  V1.3  John Strait.
! 1. Fixed another bug or two in multi-sector transfers.
! 2. Added stuff for exceptions.
!
! 14 Feb 81  V1.2  John Strait.
! 1. Cleaned-up the code a little bit.
! 2. Fixed a couple bugs in multi-sector disk transfers.
! 3. Fixed a bug in Video interrupt service.
!
! 9 Sep 80  V1.1  John Strait.
! Fix bug in speech out: not clearing bit in Z80Status.
!
!---------------------------------------------------------------------------

$Include IO.Dfs
$Include Perq.Dfs




        Decimal;
$Include Except.Dfs
        Octal;




$Title Register definitions.

define(r370,370);
define(dskTmp,200);
define(dskDCBptr,201);  !Pointer to the DCB we are working on
define(dskCMD,202);     !The command we are doing
define(dskAddr,203);    !the Disk Address we are doing it to
define(dskCyl,204);   !Where the disk heads are now
define(dskSeek,205);    !how many tracks to seek, known to Z80 microcode
define(dskNumSec,206);  !How many sectors to transfer
define(dskIntrLevel,207); !1 if code running from interrupt, 0 if from Qcode
define(ioKbdCb,222);
define(ioRsInCb,223);
define(ioRsOutCb,224);
define(io488InCb,266);

define(Z80Chr, 226);    ! Last character received from Z80
define(Z80Buff,230);    ! Adr of ChrCtlBlk for active device
define(Z80Tmp,231);
define(Z80Byte,257);    !Bit 0 = input hi/lo byte indicator, bit 7 is for output
define(Z80ByteCnt,232); !Byte count for Z80 data coming in

define(Z80OData,235);
define(Z80Otmp,236);
define(Z80OBytCnt,237);
define(Z80OAdr,240);

define(Z80FloppyDcb,242);
define(Z80RsoTmp, 243);
define(Z80OtmpState,244);
define(Z80SpchAdr,245);
define(Z80SpchCnt,246);
define(Z80488Adr,263);
define(Z80488Cnt,264);
define(Z80488Cmd,265);
define(Z80StateAdr,247);
define(Z80StateType,250);
define(Z80Restart,251);
define(Z80VIntr,256);
define(Z80OVintr,260);
define(ioTabAdr,252);   ! Address of Tablet Words
define(dpyCntlBlk,255); !Address of Display Control Block
define(Z80FlpAdr,262);
define(dpyCm,372);      !Pointer to current Video command

define(dpyCBase,373);   !Base address of Cursor Pattern

define(ClkTim1,276);    ! Low order 60 Hz. clock
define(ClkTim2,277);    ! High order 60 Hz. clock


{Ether3MBaud not assembled.

!*** NOTE:  IOE3.Micro is included later and has register definitions for
!           the 3MHz Ethernet support.

 Ether3MBaud not assembled.}



$Title Constant definitions.

constant(dskStat,100);  !io address of Status Register
constant(dskCntl,301);  !io address of Command/Control Register
constant(dskHead,302);  !io address of Head Number Register
constant(dskCylSec,310);!io address of Cylinder/Sector Number Register
constant(dskFSNlo,311); !io address of FileSerialNumber low bits Register
constant(dskFSNhi,312); !io address of FileSerialNumber hi bits Register
constant(dskLBN,313);   !io address of LogicalBlockNumber Register
constant(dskHdrLo,331); !io address of Header Buffer Address low bits Register
constant(dskHdrHi,321); !io address of Header Buffer Address hi bits Register
constant(dskDataLo,330);!io address of Data Buffer address low bits Register
constant(dskDataHi,320);!io address of Data Buffer address hi bits Register
constant(ioBlkSizeOffset,2); !Offset in Device Table for Buffer Size
constant(ioCbOffset,0); !Offset in Device Table for CircularBuffer Pointer
constant(ioFloppyBlkSizeOffset,32); !Offset in DevTab for Floppy Blk Size
             !There are 10 words/dev table entry. (10 * 3) + 2 = 32
constant(ioSpchBlkSizeOffset,42); !Offset in DevTab for Speech Blk Size
             ! (10 * 4) + 2 = 42
constant(ioIntTentry,0);    !Master Z80 (IO Init) entry in Device Table
constant(dskDTentry,10);    !Hard Disk entry in Device Table (10 * 1)
constant(ioDpyDTentry,210); !Display entry in Device Table (10 * 21)
constant(ioTabDTentry,70);  !Tablet entry in DevTab (10 * 7)
constant(ioKbdDTentry,100); !Keyboard entry in Device Table (10 * 10)
constant(ioRsiDTentry,110); !RS232 Input entry in DevTab (10 * 11)
constant(ioRsoDTentry,120); !RS232 Output entry in DevTab (10 * 12)
constant(ioFlpDTentry,30);  !Floppy entry in DevTab (10 * 3);
constant(io488InDTentry,130);  !GPIB Input entry in DevTab (10 * 13)
constant(io488OutDTentry,50);  !GPIB Output entry in DevTab (10 * 5);
constant(ioVltDTentry,60);  !Voltage Monitor entry in DevTab (10 * 6)
constant(ioSpchDTentry,40); !Speech entry in DevTab (10 * 4)
constant(ioSetDTentry,140); !SetStatus entry in DevTab (10 * 14)
constant(ioGetDTentry,150); !GetStatus entry in DevTab (10 * 15)
constant(Z80Prefix,153);    !Flag Char sent by Z80 at start of message
constant(ioIntMaskOffset,3);
constant(Z80NulIntMsk,3);   !guaranteed word of 0 in dev table
constant(dskIntMsk,13);     !Hard Disk Interrupt Mask offset in DevTab
constant(Z80VltIntMsk,63);  !Voltage Interrupt Mask offset in DevTab
constant(Z80KbdIntMsk,103); !Keyboard Interrupt Mask offset in DevTab
constant(Z80RsoIntMsk,123); !RS232 Output Interrupt Mask offset in DevTab
constant(Z80RsiIntMsk,113); !RS232 Input Interrupt Mask offset in DevTab
constant(ClkIntMsk,73);     !60 Hz Clock Interrupt Mask offset in DevTab
constant(Z80GetIntMsk,153); !GetStatus Interrupt Mask offset in DevTab
constant(Z80SetIntMsk,143); !SetStatus  Interrupt Mask offset in DevTab
constant(Z80SpkIntMsk,43);  !Speech Interrupt Mask offset in DevTab
constant(Z80488InIntMsk,133);  !GPIB Input Interrupt Mask offset in DevTab
constant(Z80488OutIntMsk,53);  !GPIB Output Interrupt Mask offset in DevTab
constant(Z80FlpIntMsk,33);  !Floppy Interrupt Mask offset in DevTab
constant(Z80DoSeek,20);     !bit for Z80WantOutput for disk seek
constant(Z80DoSpeech,2);
constant(Z80DoFloppy,4);
constant(Z80DoRS232,1);
constant(Z80DoGpib,10);
constant(Z80DoSetStatus,40);
constant(Z80DoGetStatus,100);
constant(Z80DataIOB,307);
constant(OVRErr,140000);        ! status bits to set for overrun error
constant(cbRdOff,2);            ! offsets to circular buffer info
constant(cbWrOff,1);
constant(cbLnOff,3);
constant(cbBufOff,2);           ! offset from IOCB to number of blocks/buffs



constant(Z80St0,5100);          ! Dispatch point for Z80 input intrs
constant(Z80St1,5200);
constant(Z80Msg0,5300);         ! Dispatch point for message type
constant(Z80Msg1,5400);

Constant(Z80OSt,5500);          ! Dispatch point for Z80 output intrs




        Place(4400,5777);




$Title Hard disk.

! Hard disk.
!-----------------------------------------------------------------------------
!
!The format of a dsk DCB
!  dskDCB: Packed Record
!            Data: ^dskData;
!            Command: (Idle,WriteCheck,Write,FormatWrite,ReadCheck,FormatRead
!                      SeekOnly, Reset);
!            NumSec: 0..255;      {Number of sectors to transfer}
!            DiskAddr: Packed Record
!                        Sect: (0..29);    {5 bits}
!                        Head: (0..7);     {3 bits}
!                        Cyl:  (0..201);   {8 bits}
!                      end;
!            FileSerialNumber: Long;         {Start of Header Block}
!            LogicalBlockNumber: Integer;
!            NumberOfGoodBytes: Integer;
!            NextBlock: Long
!            PreviousBlock: Long;            {End of Header Block}
!            Result:   Packed Record
!                        CntrlrErr: (.....)   {3 bits}
!                        IllegalCmd: Boolean;
!                        TrackZero:  Boolean;
!                        WriteFault: Boolean;
!                        SeekCompl:  Boolean;
!                        DriveReady: Boolean;
!                      end;
!            OsUnused: Array [0..2] of Unspecified;
!          end;
!
!-----------------------------------------------------------------------------

! Hard disk StartIO.
!-----------------------------------------------------------------------------
!
!-----------------------------------------------------------------------------

dskStart: dskIntrLevel := 0, Case(StartIO,1);
dskGetDcbPtr: ioDevTab + dskDTentry, Fetch2; 
          Call(ioTLate);                   !Get DCB ptr
          dskDCBptr := ioPhysAdr, Call(ioXLateA); !It was a virtual address
          not ioPhAdrHi, IOB(dskHdrHi);    !Let Hardware have upper bits
dskDoSector: dskTmp := dskDCBptr, Fetch4;  !get Data Buf, Cmd, NumSec & DskAdr
          dskTmp := dskTmp + 4;            !offset to header data
          dskTmp xnor C1777, IOB(dskHdrLo);!Give header address to controller
          ioOffset := MDI;                    ! pick up the segment number
          ioSeg := MDI;                 ! And his Data Buffer offset
          dskCMD := MDI;                   !The command to do
          dskAddr := MDI, Call(ioXlateA);!And the place on the disk to do it to
          ioPhysAdr xnor C1777, IOB(dskDataLo); !Put PA of Buf ptr into dsk controller
          not ioPhAdrHi, IOB(dskDataHi);
          dskAddr, Field(5,3);             !Get head field
          SHIFT, IOB(dskHead);
          dskAddr, IOB(dskCylSec);         !Let Hardware know about addr
          dskDCBptr+4, Fetch4;     !pick up the FSN/LBN
          dskCMD, Field(10,10);    !Num sectors to transfer
          dskNumSec := SHIFT;      !Will do multi-sector xfer if <= 1
          MDI, IOB(dskFSNlo);      !Here comes the file serial number 
          MDI, IOB(dskFSNhi);      !  a 32 bit quantity
          MDI, IOB(dskLBN);        !And then the Logical Block Number
          dskCMD := dskCMD and 47; !Get rid of all but real command bits
          dskAddr, Field(10,10);   !get Cylinder field
          dskSeek:=SHIFT-dskCyl;!Compare to where we are now
          dskSeek, IF Neq GoTo(dskCallZ80); !If not 0, Seek is required
dskDoCmd: dskCMD - 6;              !This command is needs extra work
          if eql GoTo(dskSeekOnly);
          dskCMD, IOB(dskCntl);    !start disk
          dskIntrLevel;
          if Odd GoTo(NiceRet);    !Dismiss intr if thats how we got here
          TOS := not 0, push, NextInst(0);!otherwise, return with NextInst, TOS good
          
dskCallZ80: dskCyl := dskCyl + dskSeek, IF Lss GoTo(dskSeekBack);
          10, IOB(dskCntl);
          GoTo(Z80DiskSeek);
dskSeekBack: dskSeek := not dskSeek;
          dskSeek := dskSeek + 1;
          0, IOB(dskCntl);
          GoTo(Z80DiskSeek);
dskSeekOnly: IOB(dskStat);  !Code 6 is seek only, finsih now
          dskTmp := IOD, GoTo(dskISrvA);

! Hard disk interrupt service.
!-----------------------------------------------------------------------------
!
!-----------------------------------------------------------------------------

dskIntrServ: dskIntrLevel := 1,IOB(dskStat),loc(DiskInt); !Disk Interrupt Service
          dskTmp := IOD;              !Get disk status and save it
          0, IOB(dskCntl);            !Clear the interrupt quick
dskISrvA: dskTmp and 47;              !Check errors (Controller and WriteFault)
          dskNumSec := dskNumSec - 1, if Neq GoTo(dskCmdDone);!Count # sectors
          IF Gtr GoTo(dskMoreSecs);
dskCmdDone: MA := dskDCBptr+14, Store;  !Store the result status
          MDO := dskTmp;              !The disk status code
          ioDevTab + dskIntMsk, Fetch;
          UserIntr := MDI or UserIntr; !Cause Pascal interrupt
          dskIntrLevel;
          if Odd Return; 
          TOS := not 0, push, NextInst(0);
dskMoreSecs: MA := dskDCBptr, Fetch;  !Get the Data buffer Pointer Offset
          dskTmp := MDI;
          MA := dskDCBptr, Store;     !Update the Data buffer offset
          MDO := dskTmp + 400;
          dskDCBptr+6, Fetch;         !Pick up the LogicalBlockNumber
          dskTmp := MDI;
          dskDCBptr+6, Store;         !Update it
          dskTmp + 1;
          dskDCBptr+2, Fetch;         !Get Cmd/NumSec
          dskTmp := MDI;
          dskDCBptr+2, Store;
          MDO := dskTmp - 400;        !Decrement NumSec
          dskDCBptr+10, Fetch;        !Get the Next Disk Address
          dskTmp := MDI;
          dskDCBptr+3, Store;         !Update the Disk Address
          dskTmp, GoTo(dskDoSector);

Z80DiskSeek: Z80WantOutput := Z80WantOutput or Z80DoSeek, Call(Z80StartScan);
          dskIntrLevel;
          if Odd Goto(NiceRet);
          TOS := 0, Push, NextInst(0);




$Title Circular buffered devices.

! Circular buffers.
!-----------------------------------------------------------------------------
!
!Format of a CircularBuffer
!       CirBuffer:  Record      {Must be aligned on a Quad Boundary}
!                    cbLen:  (0..MaxLen);  {Actually has "MaxLen" in it}
!                    cbRdPtr: (0..MaxLen);
!                    cbWrPtr: (0..MaxLen);
!                    cbBuf: Array [0..MaxLen] of XXX (A one word packed record)
!                   end;
!
!-----------------------------------------------------------------------------

! Circular buffered StartIOs.
!-----------------------------------------------------------------------------
!
!-----------------------------------------------------------------------------

cbPutChrQ: ioChar := TOS, pop, Call(cbSetUpQ),case(StartIO,16); !cir buf put
                                            ! TOS = Char
                                            ! TOS-1,TOS-2 = VA of control block
cbPutChr1: Call(cbPut);
cbPutChr2: TOS := ioTmp, push, NextInst(0); !Return results on TOS




cbGetChrQ: Call(cbSetUpQ), case(StartIO,17);    !special cir buf get
                                        !TOS,TOS-1 = VA of control block
cbGetChr1: Call(cbGet);
cbGetChr2: TOS := ioChar, Push;        !Return Results on TOS - 1
           TOS := ioTmp, Push,NextInst(0);  !Return Success flag on TOS




cbKbdGet:  ioPhysAdr := ioKbdCb, Call(cbSetUp), Case(StartIO,10);
           GoTo(cbGetChr1);




cbRS232Get: ioPhysAdr := ioRsInCb, Call(cbSetUp), Case(StartIO,11);
           GoTo(cbGetChr1);




cbRS232Put: ioPhysAdr := ioRsOutCb, Call(cbSetUp), Case(StartIO,12);
           ioChar := TOS, Call(cbPut);
           TOS := ioTmp;                !Return results on TOS
           if intrpend call(vecint);    !give the io a break
           Z80WantOutput := Z80WantOutput or Z80DoRS232, Call(Z80StartScan);
                                   !Queue a request for the Z80 to start it
           NextInst(0);  




cb488Get:  ioPhysAdr := io488InCb, Call(cbSetUp), Case(StartIO,13);
           GoTo(cbGetChr1);

! Routine cbSetUpQ.
!-----------------------------------------------------------------------------
!
! Routine to initialize registers from a CircularBuffer
!
!-----------------------------------------------------------------------------

cbSetUpQ: Call(ioTLateB);               !Get Circular Buffer Pointer on TOS
cbSetUp:  ioPhysAdr, Fetch4;     !entry point for io device microcode
          ioPhysAdr := ioPhysAdr + 3;  !Set ioPhysAdr to 1st data item
          ioLen := MDI;
          ioRdPtr := MDI;
          ioWrPtr := MDI, return;

! Routine cbPut.
!-----------------------------------------------------------------------------
!
!Routine to put an item in a CircularBuffer
!  cbSetUp must be called prior to calling cbPut
!
!-----------------------------------------------------------------------------

cbPut:    ioTmp := ioRdPtr;     !must calculate (ioRdPtr - 1) - ioWrPtr
cbPut1:   ioTmp := ioTmp - 1, If Eql GoTo(cbPutOvr);  !To see if buffer is full
          ioTmp - ioWrPtr;
          ioTmp := 0, if eql Return;    ! return with 0 => failure
          MA := ioPhysAdr + ioWrPtr, Store;  !Put the data item in the buffer
          ioChar;  !the data
          ioWrPtr := ioWrPtr + 1;  !Now update your pointer
          ioWrPtr - ioLen;         !Watch out for wrap around
          ioTmp := not 0, If Neq GoTo(cbPutDone); 
          ioWrPtr := 0;            !Wrap around occured, start at top of buffer
cbPutDone:ioPhysAdr - cbWrOff, Store;       ! write out new write pointer
          ioWrPtr;
          ioTmp, Return;                ! return with -1 => success
cbPutOvr: ioTmp := ioLen, GoTo(cbPut1); !RdPtr was 0, if WrPtr = Len-1 => full

! Routine cbPut.
!-----------------------------------------------------------------------------
!
!Routine to get an item from a circular buffer
!  cbSetUp must be called prior to calling cbGet
!
!-----------------------------------------------------------------------------

cbGet:    ioRdPtr - ioWrPtr;            !Check for buffer empty
          ioTmp := 0,  if Eql Return;   ! return with 0 => no char available
          ioPhysAdr + ioRdPtr, Fetch;   !get the char
          ioRdPtr := ioRdPtr + 1;       !update the Read Pointer
          ioRdPtr - ioLen;              !Check for wrap around
          ioChar := MDI, If Neq GoTo(cbGetDone);
          ioRdPtr := 0;                 !Wrap around occured, start at top
cbGetDone: ioPhysAdr - cbRdOff, Store;  ! write out new read pointer
          ioRdPtr;
          ioTmp := not 0, return;       ! return with -1 => success




$Title Floppy disk.

! Floppy disk StartIO.
!-----------------------------------------------------------------------------
!
!-----------------------------------------------------------------------------

FloppyStart: ioDevTab + ioFlpDTentry, Fetch2,  Case(StartIO,3);
           Call(ioTLate);                                    !IOCB entry
           Z80FloppyDCB := ioPhysAdr, Fetch2;
           Call(ioTLate);                !buffer address
           Z80FlpAdr := ioPhysAdr;
           Z80FlpAdr := Z80FlpAdr - 1;   !incremented before first memory ref
           Z80WantOutput := Z80WantOutput or Z80DoFloppy, Call(Z80StartScan);
           TOS := not 0, Push, NextInst(0);




$Title Speech.

! Speech StartIO.
!-----------------------------------------------------------------------------
!
!-----------------------------------------------------------------------------

Z80SpeechStart: Z80spchCnt, Case(StartIO,4);  !check speech io in progress
           if neq goto(ioBadBerries);         !if so, can't do
           ioDevTab + ioSpchDTentry, Fetch2;
           Call(ioTLate);                     !Get dcb ptr
           ioTmp := ioPhysAdr, Fetch2; 
           Call(ioTLate);                   !Get data buffer pointer
           ioDevTab + ioSpchBlkSizeOffset, Fetch; !Get Block Size
           Z80SpchAdr := ioPhysAdr;       !Save buffer address
           Z80WantOutput:=Z80WantOutput or Z80DoSpeech;
           ioTmp1 := MDI, If IntrPend Call(VecInt);
           ioTmp + cbBufOff, Fetch;              !Get # buffers
           Z80SpchCnt := 0;
           MDI, RightShift(10);           !Its iun the hi byte
           ioTmp := Shift;                !poor man's multiply
Z80SpchSt1: ioTmp := ioTmp - 1;           !to get total bytecount
           Z80SpchCnt := Z80SpchCnt + ioTmp1, If gtr goto(Z80SpchSt1);
           Z80SpchAdr := Z80SpchAdr - 1, Call(Z80StartScan);!do all wds in buff
           TOS := not 0, Push, NextInst(0);     !All is well




$Title GPIB.

! GPIB StartIO.
!-----------------------------------------------------------------------------
!
!-----------------------------------------------------------------------------

GPIBstart: ioDevTab + io488OutDTentry, Fetch2,  Case(StartIO,5);
           Call(ioTlate);
           ioTmp := ioPhysAdr, Fetch4;
           Z80WantOutput := Z80WantOutput or Z80DoGpib;
           ioOffset := MDI;
           ioSeg := MDI;
           Z80488Cmd := MDI;
           Z80488Cnt := MDI, Call(ioTLateA);
           Z80488Adr := ioPhysAdr, Call(Z80StartScan);
           TOS := Not 0, Push, NextInst(0);




$Title SetStatus and GetStatus.

! SetStatus and GetStatus StartIOs.
!-----------------------------------------------------------------------------
!
!-----------------------------------------------------------------------------

ioSetStatus:  Tmp := ioSetDTentry,Call(ioWaitPrevSetStat), Case(StartIO,14);
           if LSS goto (ioSetDHeads);   ! MAB special to locate heads
           Z80WantOutput := Z80WantOutput or Z80DoSetStatus, Call(Z80StartScan);
           NextInst(0);

ioSetDHeads:  dskCyl := Tos, Pop, NextInst(0); ! Set current cylinder number




ioGetStatus: Tmp := ioGetDTentry, Call(ioWaitPrevSetStat), Case(StartIO,15);
                                   !Dont Get until last Set
           Z80WantOutput := Z80WantOutput or Z80DoGetStatus, Call(Z80StartScan);
           NextInst(0);

ioWaitPrevSetStat:  if intrpend call(VecInt);      !This may take a while
           Z80WantOutput and 140;            !Wait for any prior SetStat/GetStat
           If Neq GoTo(ioWaitPrevSetStat);         !  to finish before starting
           Z80StateType := TOS, pop;               !Get the channel number
           Z80StateType, if LSS return;            ! MAB special code to locate disk heads
           ioDevTab + Tmp, Fetch2;
           Call(ioTLate);
           Z80StateAdr := ioPhysAdr;               !Save pa of buffer address
           Z80StateType, return;




$Title Z80 to Perq communications.

! Z80 to Perq interrupt service.
!-----------------------------------------------------------------------------
!
!-----------------------------------------------------------------------------

Z80IntSrv: IOB(106),loc(Z80IInt);             !Read the chr
           Z80Chr := IOD and 377;             !Punt upper bits
           Z80State - 20, Field(0,4);         !Dispatch to right routine
           Z80State, if Geq Dispatch(Z80St1); !dispatch to states 20..37
           Dispatch(Z80St0);                  !dispatch to states 0..17

Z80BumpState: Z80State := Z80State + 1, Return; !Next State please




!       State 0 - Idle.

case(Z80St0,0), Z80Chr - Z80Prefix;        ! state 0 - idle
           if Neq GoTo(NiceRet);           !only accept the flag char
           Z80State := 1, Return;         !Got it, next byte is message type




!       State 1 - Message type, begin communication.

case(Z80St0,1), Z80Chr - 20, Field(0,4);  ! state 1 - Dispatch on message type
           Z80Chr, if Geq Dispatch(Z80Msg1);  !dispatch to messages 20..37
           Dispatch(Z80Msg0);                 !dispatch to messages 0..17


!       Message 0 - Unknown message type.

  Case(Z80Msg0,0),  Z80State := 0, GoTo(NiceRet);


!       Message 1 - Keyboard character.

  Case(Z80Msg0,1),  Z80Buff := ioKbdCb;
  Z80MsA:           Z80State := 2, GoTo(NiceRet);


!       Message 2 - RS232 characters.

  Case(Z80Msg0,2),  Z80Buff := ioRsInCb;
                    Z80VIntr := Z80RsiIntMsk;
                    Z80State := 3, GoTo(NiceRet);


!       Message 3 - Tablet data.

  Case(Z80Msg0,3),  Z80State := 5, GoTo(NiceRet);


!       Message 4 - Clock data.

  Case(Z80Msg0,4),  Z80State := 11, GoTo(NiceRet);


!       Message 5 - Floppy data.

  Case(Z80Msg0,5),  Z80Buff := Z80FlpAdr;
                    Z80VIntr := Z80FlpIntMsk;
                    Z80State := 15, GoTo(NiceRet);


!       Message 6 - GPIB data.

  Case(Z80Msg0,6),  Z80Buff := io488InCb;
                    Z80VIntr := Z80488InIntMsk;
                    Z80State := 20, GoTo(NiceRet);


!       Message 7 - RS232 status.

  Case(Z80Msg0,7),  Z80Buff := Z80StateAdr;
  Z80GtStat:        Z80VIntr := Z80GetIntMsk; 
                    Z80State := 17, GoTo(NiceRet);


!       Message 10 - Tablet status.

  Case(Z80Msg0,10), Z80Buff := Z80StateAdr, GoTo(Z80GtStat);


!       Message 11 - Keyboard status.

  Case(Z80Msg0,11), Z80Buff := Z80StateAdr, GoTo(Z80GtStat);


!       Message 12 - Seek complete.

  Case(Z80Msg0,12), dskIntrLevel := 1;           ! MAB
                    Z80State:=0, GoTo(dskDoCmd);

!       Message 13 - Status change.

  Case(Z80Msg0,13), Z80State := 12, GoTo(NiceRet);


!       Message 14 - Voltage data.

  Case(Z80Msg0,14), ioDevTab + ioVltDTentry, Fetch2;!msg 14 - Voltage Data coming
                    Z80VIntr := Z80VltIntMsk, Call(ioTlate);
                    Z80Buff := ioPhysAdr;
  SetState13:       Z80State := 13, GoTo(NiceRet);


!       Message 15 - Voltage status.

  Case(Z80Msg0,15), Z80Buff := Z80StateAdr, GoTo(Z80GtStat);


!       Message 16 - Clock status.

  Case(Z80Msg0,16), Z80Buff := Z80StateAdr, GoTo(Z80GtStat);


!       Message 17 - GPIB status.
!       ********** - Where did this code go?



!       Message 20 - Floppy status.

  Case(Z80Msg1,0),  Z80Buff := Z80StateAdr, GoTo(Z80GtStat);


!       Message 21 - Floppy done.

  Case(Z80Msg1,1),  Z80State := 16;
                    Z80VIntr := Z80FlpIntMsk, Goto(NiceRet);




!       State 2 - Keyboard character.

Case(Z80St0,2), ioDevTab + Z80KbdIntMsk, Fetch;
           ioChar := Z80Chr;
           Z80State := 0;               !this message is over
           UserIntr := MDI or UserIntr; !Cause an interrupt
Z80St2a:   ioPhysAdr := Z80Buff, Call(cbSetUp); !Z80Buff has ptr to cb
           Call(cbPut);                 !Put item away
           ioWrPtr := ioWrPtr - 1, If Neq GoTo(NiceRet); !return if it worked
           If Lss GoTo(Z80St2c);        !otherwise we have overflow
                                        !   the - 1 bumps ptr back to item
                                        !   the test checks for wrap around
                                        !   just occuring
Z80St2b:   ioPhysAdr + ioWrPtr, Fetch;  !no wrap around, get that last item
           nop;                         !Fetch/Store combo needs explicit nops
           nop;
           ioPhysAdr + ioWrPtr, Store;  !Restore the item
           MDO := MDI or OVRErr, Return;!with the overrun bit set
Z80St2c:   ioWrPtr := ioLen;            !here if wrap around had occured
           ioWrPtr := ioWrPtr - 1, GoTo(Z80St2b);  !set up WrPtr to end of buff




!       State 3 - RS232 byte count.

Z80St3a:
Case(Z80St0,3), Z80ByteCnt := Z80Chr, GoTo(Z80BumpState);




!       State 4 - RS232 data byte.

Case(Z80St0,4), Z80ByteCnt;
           Z80ByteCnt := Z80ByteCnt - 1, if Odd GoTo(Z80St4a);
                                        !  data is arriving for RS232
           Z80Chr, LeftShift(10);       !Data coming in,
           Z80Tmp := Shift, GoTo(NiceRet);!   Save as high byte
Z80St4a:   ioChar := Z80Tmp, If Neq GoTo(Z80St4c); !This is a low byte
           Z80State := 0;              !Count just hit 0, all done
Z80St4c:   ioDevTab + Z80VIntr, Fetch;
           ioChar := ioChar or Z80Chr; !Merge high byte with low byte
           UserIntr := MDI or UserIntr, GoTo(Z80St2a); !Put data in buf




!       State 5 - Tablet low X.

Case(Z80St0,5), Z80Tmp := Z80Chr, Goto(Z80BumpState);




!       State 6 - Tablet high X.

Case(Z80St0,6), Z80Chr, LeftShift(10);
           Z80Tmp := Shift or Z80Tmp;  !Merge with low X
           ioTabAdr, Store;            !Store as first tablet word
           Z80Tmp, GoTo(Z80BumpState);




!       State 7 - Tablet low Y.

Case(Z80St0,7), Z80Tmp := Z80Chr, GoTo(Z80BumpState);




!       State 10 - Tablet high Y.

Case(Z80St0,10), Z80Chr, LeftShift(10);
           Z80Tmp := Shift or Z80Tmp;  !Merge with low Y
           ioTabAdr + 1, Store;        !Tablet Y word, save data
           Z80Tmp, GoTo(Z80BumpState);




!       State 11 - Clock ticks.

Case(Z80St0,11), Z80State := 0, Goto(NiceRet);
! *** Moved time base maintenance to video.  GGR 31 Mar 81




!       State 12 - Status change data.

Case(Z80St0,12), Z80Status := Z80Chr;
           Z80Status := Z80Status or 340;  !Set ok for SetStatus/GetStatus
           Z80State := 0, GoTo(Z80StartScan);




!       State 13 - Byte count.

Z80St13a:
Case(Z80St0,13), Z80ByteCnt := Z80Chr;
           Z80Byte := Z80Byte and not 1,   !Start on low byte
                                         if Neq GoTo(Z80BumpState);
           Z80ByteCnt := C400, GoTo(Z80BumpState);  !zero byte count means 256




!       State 14 - Data byte.

Case(Z80St0,14), Z80Byte;
           Z80Byte := Z80Byte xor 1, if Odd GoTo(Z80St14a);
           Z80ByteCnt := Z80ByteCnt - 1;
           Z80Tmp := Z80Chr, if Gtr GoTo(NiceRet);!low byte, done if byt cnt = 0
           Z80Chr := 0;                !No high byte if count was odd
Z80St14a:  Z80Chr, LeftShift(10);      !here on high byte
           Z80Tmp := Shift or Z80Tmp;  !merge hi byte with low byte
           Z80Buff := Z80Buff + 1, Store;  !Put word in memory
           Z80Tmp;                     !Merged data
           Z80ByteCnt := Z80ByteCnt - 1;!Check Byte Count
           If gtr GoTo(NiceRet);       !more bytes to go
           ioDevTab + Z80VIntr, Fetch;
           Z80State := 0;              !all done
           UserIntr := MDI or UserIntr, GoTo(NiceRet);!Cause done intr




!       State 15 - Floppy data.

Case(Z80St0,15), Z80FloppyDcb+14, Store;
           Z80Chr;
           Z80VIntr := Z80FlpIntMsk, Goto(SetState13);




!       State 16 - Floppy done, concise status.

Case(Z80St0,16), Z80FloppyDcb+14, Store;
           Z80Chr;
           ioDevTab + Z80FlpIntMsk, Fetch;
           Z80State := 0;
           UserIntr := MDI or UserIntr, Goto(NiceRet);




!       State 17 - GetStatus byte count.

Case(Z80St0,17), Z80State := 13;
           Z80Buff, Store, Goto(Z80St13a);




!       State 20 - GPIB byte count.

Case(Z80St1,0), Goto(Z80St3a);




!       State 21 - GPIB data.

Case(Z80St1,1), Z80Tmp := 0;
           Z80ByteCnt := Z80ByteCnt - 1, GoTo(Z80St4a);




$Title Perq to Z80 communications.

! Start Perq to Z80 communication.
!-----------------------------------------------------------------------------
!
!-----------------------------------------------------------------------------

Z80StartScan: Z80OState;  !Here to start a scan, check to see if we are busy
           If Neq Return;!something already in progress
Z80Scan:   Z80OTmp := Z80WantOutput;
           Z80Otmp := Z80Otmp and Z80Status; !Clear out any wants that cant be
           Z80Otmp and Z80DoSeek;
           Z80Otmp and Z80DoSpeech,  if neq GoTo(Z80StartSeek);
           Z80Otmp and Z80DoFloppy,  if neq GoTo(Z80StartSpeech);
           Z80Otmp and Z80DoGpib,    if neq GoTo(Z80StartFloppy);
           Z80Otmp and Z80DoRS232,   if neq GoTo(Z80StartGpib);
           Z80Otmp and Z80DoSetState,if neq GoTo(Z80StartRS232);
           Z80Otmp and Z80DoGetState,if neq GoTo(Z80SSetState);
                                     if neq GoTo(Z80SGetState);
           GoTo(NiceRet);

Z80FirstByte: C400 or 153, IOB(Z80DataIOB);  !Send Flag Byte
           Z80OState := 1, GoTo(NiceRet);


!       Message 1 - Start RS232 output.

Z80StartRS232: ioPhysAdr := ioRsOutCb, Call(cbSetUp);!Get read and write pointer
           Z80WantOutput := Z80WantOutput and not Z80DoRS232;
           Z80Status := Z80Status and not Z80DoRS232;
           Z80OBytCnt := ioWrPtr;   !Compute how many chars are in buffer
           Z80OBytCnt := Z80OBytCnt - ioRdPtr; !as WrPtr - RdPtr
           Z80Otmp := 1, if geq goto(Z80StRs1);   !But watch out for wrap around
           Z80OBytCnt := Z80OBytCnt + ioLen; !wrap around occurred, fix count
Z80StRs1:  Z80OBytCnt - 20;  !Don't send more than 16. bytes
           Z80OtmpState := 11, if leq GoTo(Z80FirstByte);
           Z80OBytCnt := 20, GoTo(Z80FirstByte);


!       Message 2 - Start floppy.

Z80StartFloppy: Z80Otmp := 2;  !Command Code 2
           Z80WantOutput := Z80WantOutput and not Z80DoFloppy;
           Z80Status := Z80Status and not Z80DoFloppy;
           Z80OVIntr := Z80NulIntMsk;
           Z80OtmpState := 4, GoTo(Z80FirstByte);


!       Message 3 - Start GPIB output.

Z80StartGpib: Z80Otmp := 3;
           Z80OBytCnt := Z80488Cnt;
           Z80OVintr := Z80488OutIntMsk;
           Z80OAdr := Z80488Adr;
           Z80OAdr := Z80OAdr - 1;        ! incremented before first fetch
           Z80WantOutput := Z80WantOutput and not Z80DoGpib;
           Z80Status := Z80Status and not Z80DoGpib;
           Z80OtmpState := 13, GoTo(Z80FirstByte);


!       Message 4 - Start speech.

Z80StartSpeech: Z80Otmp := 4; !Command Code 4 
           Z80spchCnt := Z80spchCnt - 40;    !send only 40 bytes at a time
           Z80OBytCnt := 40, if eql goto(Z80SSpc2); !even tho buffer is bigger
           Z80OVintr := Z80NulIntMsk;        !no interrupt on completion
           Z80Restart := Z80Restart or Z80DoSpeech;  !keep sending chunks
Z80SSpc1:  Z80OAdr := Z80SpchAdr; !Address to doit tuit
           Z80SpchAdr := Z80SpchAdr + 20;  !Keep addr right for next time
           Z80WantOutput := Z80WantOutput and not Z80DoSpeech;
           Z80Status := Z80Status and not Z80DoSpeech;
           Z80OtmpState := 2, GoTo(Z80FirstByte);
Z80SSpc2:  Z80OVintr := Z80SpkIntMsk, Goto(Z80SSpc1);   ! last transfer,
                                                        ! interrupt when done


!       Message 5, 6, 7, 11, 12, 14 - Start SetStatus.

Z80SSetState:  Z80Otmp := Z80StateType;   !Command code 5,6,7,11,12,14  SetState
           Z80OAdr := Z80StateAdr, Fetch; !Get Byte count from 1st word in buff
           Z80WantOutput := Z80WantOutput and not Z80DoSetState;
           Z80OVintr := Z80SetIntMsk;
           Z80OtmpState := 2;
           Z80OBytCnt := MDI, GoTo(Z80FirstByte);   !here is byte count


!        Message 10 - Start seek.

Z80StartSeek: Z80Otmp := 10;                !Start Seek, Send code 10
           Z80WantOutput := Z80WantOutput and not Z80DoSeek;
           Z80OData := dskSeek;
           Z80OtmpState := 10, Goto(Z80FirstByte);


!       Message 13 - Start GetStatus.

Z80SGetState:  Z80Otmp := 13;      !Command code 13  GetStatus
           Z80WantOutput := Z80WantOutput and not Z80DoGetState;
           Z80OData := Z80StateType;
           Z80OAdr := Z80StateAdr;
           Z80OtmpState := 10, GoTo(Z80FirstByte);

! Perq to Z80 interrupt service.
!-----------------------------------------------------------------------------
!
!-----------------------------------------------------------------------------

Z80OIntSrv: Z80OState, Field(0,4),loc(Z80OInt);
           Dispatch(Z80OSt);     !Go to current state

! General Purpose - On to next sequential state and return
Z80OBumpState: Z80OState := Z80OState + 1, GoTo(NiceRet);


!       State 1 - Send Message Type.

Case(Z80OSt,1), Z80Otmp or C400, IOB(Z80DataIOB); !Send Message Type
           Z80OState := Z80OtmpState, GoTo(NiceRet);         !What state is next

!       State 2 - Send Byte Count.

Case(Z80OSt,2), Z80OBytCnt or C400, IOB(Z80DataIOB); !Send Byte Count
           Z80Byte := Z80Byte and not 200, Goto(Z80OBumpState);
                                                  !Start with low byte


!       State 3 - Data Byte Going out.

Case(Z80OSt,3), Z80Byte;
           Z80Byte := Z80Byte xor 200, if ByteSign GoTo(Z80OSt3b);
           Z80OAdr := Z80OAdr + 1, Fetch;         !Get a data word - do low byte
           Z80OBytCnt := Z80OBytCnt - 1, LeftShift(10);!Check byte Count
                                                  !expiration & preset shifter
           Z80OData := MDI, if eql goto(Z80OSt3e);!Save Data, drop out if done
           Z80OData or C400, IOB(Z80DataIOB);     !Send out low byte

           Goto(NiceRet);                         ! must allow time to drop
                                                  ! interrupts, so don't get
                                                  ! the "IOB" too close to "if
                                                  ! IntrPend"

! More for State 3
Z80OSt3b:  Z80OBytCnt := Z80OBytCnt - 1;          !Here on high byte
           If neq goto(Z80OSt3d);                 !Check for end of msg

Z80OSt3c:  Z80WantOutput := Z80WantOutput or Z80Restart; !Last byte is gone
           ioDevTab + Z80OVintr, Fetch;           !Request Done Interrupt
           Z80Restart := 0;                       !No more restarts
           Z80OState := 0;                        !No more bytes
           UserIntr := MDI or UserIntr;           !Request Interrupt here

Z80OSt3d:  Z80OData, RightShift(10);              !Send the high byte
           Shift or C400, IOB(Z80DataIOB);
           GoTo(NiceRet);

Z80OSt3e:  Z80OData := Shift, GoTo(Z80OSt3c);  !No more bytes on an odd boundary

!       State 4 - Floppy head, unit.

Case(Z80OSt,4), Z80FloppyDcb + 2, Fetch;
           Z80OData := MDI;
           Z80OData or C400, IOB(Z80DataIOB);
           Z80OState := Z80OState + 1, GoTo(NiceRet);


!       State 5 - Floppy cylinder.

Case(Z80OSt,5), Z80OData, RightShift(10);
           Shift or C400, IOB(Z80DataIOB);
           Z80OState := Z80OState + 1, GoTo(NiceRet);


!       State 6 - Floppy sector.

Case(Z80OSt,6), Z80FloppyDcb + 3, Fetch;
           Z80OData := MDI;
           Z80OData or C400, IOB(Z80DataIOB);
           Z80OState := Z80OState + 1, GoTo(NiceRet);


!       State 7 - Floppy command.

Case(Z80OSt,7), Z80OData, RightShift(10);
           Shift or C400, IOB(Z80DataIOB);
           Z80OState := 2;                        !Byte count is next
           Z80FloppyDcb + 4, Fetch;               !Get Buffer size
           Z80OAdr := Z80FlpAdr;                  !The Physical Addr of buffer
           Z80OBytCnt := MDI and 777;             !buffer size
           if Neq GoTo(NiceRet);
           Z80OBytCnt := 1, GoTo(NiceRet);        !change buffer size zero to 1


!       State 10 - Seek count.

Case(Z80OSt,10), Z80OData or C400, IOB(Z80DataIOB);
           Z80OState := 0, GoTo(NiceRet);


!       State 11 - RS232 byte count.

Case(Z80OSt,11), Z80OBytCnt or C400, IOB(Z80DataIOB);
           Z80OState := 12, GoTo(NiceRet);


!       State 12 - RS232 data byte.

Case(Z80OSt,12), ioPhysAdr := ioRsOutCb, Call(cbSetUp);
           ioChar := 0, Call(cbGet);              !Get the byte from CirBuf
           ioChar or C400, IOB(Z80DataIOB);       !Data out
           Z80OBytCnt := Z80OBytCnt - 1;          !Count Them Bytes
           ioRdPtr - ioWrPtr,If neq GoTo(NiceRet);!More to go
           Z80OState := 0, if eql GoTo(NiceRet);  !it is, begone
           Z80WantOutput := Z80WantOutput or Z80DoRS232, return; !More came in
                               !while we were outputting


!       State 13 - GPIB command.

Case(Z80OSt,13), Z80488Cmd or C400, IOB(Z80DataIOB);
           Z80OState := 2, GoTo(NiceRet);


!       State 0 - End of message, turn off Z80 output interrupts.

Case(Z80OSt,0), Z80WantOutput and Z80Status;
           If Neq GoTo(Z80Scan);                  !If more messages are pending
           0, IOB(Z80DataIOB);                    !Turn off interrupts
           GoTo(NiceRet);




$Title Memory Parity error.

! Memory parity error interrupt service.
!-----------------------------------------------------------------------------
!
!       We simply generate a run-time error.
!
!-----------------------------------------------------------------------------


ParIntr:   IOB(147), Loc(ParInt);
           tmp3 := 0;
           tmp2 := ErrMParity, Goto(RunError);




$Title Video.

! Video interrupt service.
!-----------------------------------------------------------------------------
!
! Design:
!      To avoid wrecking raster-op, this interrupt service routine must
!      not use the shifter, and must not check for further interrupts.
!
!-----------------------------------------------------------------------------

Visloop:   dpyTmp, IOB(343), Loc(VidInt);  !Video Interrupt Service, Load VidState
           Z80State;
           dpyTmp, IOB(340), if Lss Return;  !Load LineCount
                                         ! Z80State < 0 before DevTab setup
GetNxtCm:  dpyCntlBlk+6,Fetch;
           ioTmp := dpyTmp;
           nop;
           MDI, IOB(344);                !Load cursor X Value
           dpyCm := dpyCm + 1, Fetch;    !Get the next Video Command word
           dpyCBase, IOB(342);           !Load Cursor Addr if cursor time
           ioTmp AND 1200;               !Test for Vertical load stuff bit
           dpyTmp := MDI, IF Eql Return; !This will be the next command
           ioTmp and 200;
           if Eql goto(Retrace);         !if beginning of vertical retrace
VBlank:    dpyTmp := 0;                  !simulate normal command
                                         !because dpyTmp contains garbage
           dpyCntlBlk, Fetch2;           !Fetch the Video control block
           Call(ioTLate);
           dpyCntlBlk+2, Fetch2;
           dpyCm := ioPhysAdr;           !This is addr of first command word
           dpyCm := dpyCm - 1;           !Offset cause GetNxt increments
           MDI, IOB(341);                !Load address of Screen Bit Map
           dpyCBase := MDI, GoTo(GetNxtCm); !Pick up Mem addr of cursor bit map

! *** Moved time base maintenance to video.  GGR 31 Mar 81
Retrace:   ioDevTab + ClkIntMsk, Fetch;
           UserIntr := MDI or UserIntr;   !give him an interrupt
           ioTabAdr + 2, Store2;          !store it in device table
           ClkTim1 := ClkTim1 + 1;        !Double Precision add
           ClkTim2 := ClkTim2 + 0 + OldCarry;  !To get new clock data
           return;                        !***this can't happen during T1
                                          !***following Store2


$Title Undefined interrupts.

! Undefined interrupt service.
!-----------------------------------------------------------------------------
!
!       We simply generate a run-time error
!
!-----------------------------------------------------------------------------

BadIntr1:  nop, loc(BadInt1);
BadIntr:
NetIntr:   tmp3 := 0, loc(NetInt);
           tmp2 := ErrUndfInt, Goto(RunError);




$Title 3MHz Ethernet support.

! 3MHz Ethernet support.
!-----------------------------------------------------------------------------
!
!-----------------------------------------------------------------------------

{Ether3MBaud not supported.
 $Include IOE3.Micro
 Ether3MBaud not supported.}
        Goto(BadIntr), Loc(E3Int);




$Title Initialization.

! Device table set-up StartIO.
!-----------------------------------------------------------------------------
!
!-----------------------------------------------------------------------------

devTabSetUp: tmp and 20, Case(StartIO,0);  !Do we wish to set up stack stuff?
           if eql goto (DoDevTabSet);   !if not set stack subfunction
           Call(SetQState);
           NextInst(0);

DoDevTabSet: ClkTim1 := 0;
           ClkTim2 := 0;
           Z80State := 0;      
           Z80Restart := 0, IOB(301);  !Let Z80 Go
           Z80SpchCnt := 0, Call(ioTLateB);
           
           StackReset;                                  ! DDS 362
           ioDevTab := ioPhysAdr, StackReset;           ! DDS 363
           ioDevTab, Fetch2;
           Call(ioTLate);
           IntPtr := ioPhysAdr;
           
           ioDevTab + ioDpyDTentry, Fetch2;
           Call(ioTLate);
           dpyCntlBlk := ioPhysAdr, Call(VBlank);       !set up video registers
           StackReset;                                  ! DDS 364
           
           ioDevTab + ioTabDTentry, Fetch2;
           Call(ioTLate);
           dpyTmp := 101351;
           ioTabAdr := ioPhysAdr, Call(101351);        !start screen
           StackReset;                                  ! DDS 365
           
           ioDevTab + ioKbdDTentry, Fetch2;
           Call(ioTLate);
           ioKbdCb := ioPhysAdr;
           
           ioDevTab + ioRsiDTentry, Fetch2;
           Call(ioTLate);
           ioRsInCb := ioPhysAdr;
           
           ioDevTab + ioRsoDTentry, Fetch2;
           Call(ioTLate);
           ioRsOutCb := ioPhysAdr;
           
           ioDevTab + io488InDTentry, Fetch2;
           Call(ioTLate);
           io488InCb := ioPhysAdr,                      ! GPIB
                 StackReset,                            ! DDS 366
                 nextinst(0);       




$Title ioTLate, ioTLateA, ioTLateB

! Routine ioTLate - Translate virtual address to physical address.
!-----------------------------------------------------------------------------
! Abstract:
!   This routine is used by the IO system to translate a VA to
!   a PA.
!
! Environment:
!   This routine expects a Fetch2 of the pointer to have been executed.
!   The Fetch2 will happen in T3.  Entry must be made into this routine
!   by T2.
!
! Result:
!   The PA of the memory is left in IOPhysAdr.
!
! Side Effects:
!   This procedure will place the Segment and Offset of the pointer
!   into IOSeg and IOOffset.
!
!-----------------------------------------------------------------------------

! Routine ioTLateA - Translate virtual address to physical address.
!-----------------------------------------------------------------------------
! Abstract:
!   This routine is used by the IO system to translate a VA to
!   a PA.
!
! Environment:
!   This routine expects IOSeg and IOOffset to contain the Segment and
!   the Offset portions of the pointer.
!
! Result:
!   The PA of the memory is left in IOPhysAdr.
!
!
!-----------------------------------------------------------------------------

! Routine ioTLateB - Translate virtual address to physical address.
!-----------------------------------------------------------------------------
! Abstract:
!   This routine is used by the IO system to translate a VA to
!   a PA.
!
! Environment:
!   This routine expects the pointer to be on the ESTK.
!
! Result:
!   The PA of the memory is left in IOPhysAdr.
!
! Side Effects:
!   This procedure will place the Segment and Offset of the pointer
!   into IOSeg and IOOffset.  It also removes the pointer from
!   the ESTK.
!
!-----------------------------------------------------------------------------

loc(ioTLate), ioOffset := MDI;      !entry point if a fetch of the va was made
         ioSeg := MDI, GoTo(ioTLateA);

loc(ioTLateB), ioOffset := TOS, Pop; !entry point if va is on ESTK
         ioSeg := TOS, Pop;

loc(ioTLateA), MA := ioSeg + ioSeg, Fetch2;  !entry pnt if ioSeg & ioOffset are loaded
         ioPhysAdr := MDI and not 376;
         ioPhysAdr := MDX or ioPhysAdr, if Odd goto(ioNotResident);
         ioPhysAdr := ioPhysAdr + ioOffset, return;

$Title ioXLate, ioXLateA

! Routine ioXLate - Translate virtual address to physical address.
!-----------------------------------------------------------------------------
!
! Abstract:
!   This routine is used to translate a VA to a PA.  It differs from the
!   IOTLates in that the PA is returned in two pieces. One is
!   16 bits while the other is 4 bits.
!
! Environment:
!   This procedure expects that a Fetch2 of the pointer was done.  The
!   Fetch2 will happen in T3.  That means that entry to this routine
!   must be made before T2.
!
! Results:
!   The low order 16 bits of the PA are left in IOPhysAdr.  The
!   high order 4 bits are left in IOPhAdrHi.
!
! Side Effects:
!   This procedure will set IOOffset and IOSeg. 
!
!-----------------------------------------------------------------------------

! Routine ioXLateA - Translate virtual address to physical address.
!-----------------------------------------------------------------------------
!
! Abstract:
!   This routine is used to translate a VA to a PA.  It differs from the
!   IOTLates in that the PA is returned in two pieces. One is
!   16 bits while the other is 4 bits.
!
! Environment:
!   This procedure expects the segment and offset of the pointer
!   to be in IOSeg and IOOffset.
!
! Results:
!   The low order 16 bits of the PA are left in IOPhysAdr.  The
!   high order 4 bits are left in IOPhAdrHi.
!
!-----------------------------------------------------------------------------

loc(ioXLate), ioOffset := MDI;  !entry point if a fetch of va was just made
         ioSeg := MDI;
loc(ioXLateA), MA := ioSeg + ioSeg, Fetch2;  !entry pt if ioSeg & ioOffset are loaded
         ioPhysAdr := MDI and not 376;
         ioPhAdrHi := MDI, if Odd GoTo(ioNotResident);
                                       !save upper bits in a register
         ioPhysAdr := ioPhysAdr + ioOffset;  !form actual data with a double
         ioPhAdrHi := ioPhAdrHi + 0 + OldCarry, return;  !precision add

ioNotResident: tmp3 := 0;
         tmp2 := ErrIOSFlt, Goto(RunError);
$Title Utility routines

! Routine NiceRet.
!-----------------------------------------------------------------------------
!
! Abstract:
!   General Purpose Exit (checks for other interrupts)
!
!-----------------------------------------------------------------------------

loc(NiceRet),    if IntrPend GoTo(Vecint);              !Allow more interrupts
           Return;

! Routine VecInt.
!-----------------------------------------------------------------------------
!
!-----------------------------------------------------------------------------

VecInt:    Vector(IntVec);

! Routine ioBadBerries.
!-----------------------------------------------------------------------------
!
! Signal bad StartIO.
!
!-----------------------------------------------------------------------------

ioBadBerries:  TOS := 0, NextInst(0);    !Here if StartIO should fail




        end;
