{---------------------------------------------------------------------
{ Copyright (C) 1983 - Perq Systems Corporation.
{---------------------------------------------------------------------}
module PasReal;

{-----------------------------------------------------------------------------
{
{     PasReal -  Scott L. Brown     Created: 25-Nov-81
{     Copyright (C) 1981, 1982, 1983 - Three Rivers Computer Corporation 
{ 
{ Abstract:
{
{     PasReal is an extra character input module of the Stream package.
{     Its routines are called by code generated by the Pascal compiler 
{     in response to variations on Read, Readln, Write and Writeln 
{     statements. It is one level above Module Stream and uses Stream's
{     lower-level input routines.
{
{-----------------------------------------------------------------------------}


{-----------------------------------------------------------------------------
{
{ Change Log:
{
{ 02-Feb-83         Bert Hutchings, ICL
{ Fix bug (+ for -) in fixed format specification and in round off.
{ Correct output of 0.0___01 if 0.0___005 or greater.
{ After consideration, allow output of -0.0___0 for small negatives.
{
{ 28-Oct-82         Bert Hutchings, ICL
{ WriteR entirely replaced, for better precision.
{
{ 03-May-82  V0.2   John B. Brodie
{ ReadR made slightly more accurate & remove an erroneous 'if' in build_dig...
{
{ 26-jan-82  V0.1a  Scott L. Brown
{ Modified to raise the exception NotReal instead of NotNumber (in ReadR).
{
{ 25-Nov-81  V0.0   Scott L. Brown
{ Creation of real read and write routines ReadR and WriteR.
{
{-----------------------------------------------------------------------------}


exports

 imports Stream from Stream;

 

 procedure ReadR(var F: FileType;
                 var value: real);

 procedure WriteR(var F: FileType;
                      e: real;
                      TotalWidth: integer;
                      FracDigits: integer;
                      format: integer);


private

{$R+ range checking is left on } 

imports Perq_string from Perq_String;


const

 Version = '0.2';
 
 Tab = Chr(#11);
 FF  = Chr(#14);
      
 ord_zero = ord('0');
 exp_bias = 127;



type
 vk = record  {variant kludge}
      case integer of
      1: (R: real);
      2: (L: long);
      3: (LW: integer; HW: integer);  
      4: (A: packed array[0..31] of 0..1);
      5: (S: set of 0..31)
      end;



var
 StrmNameF: PathName;     { Used for reporting exceptions. }





{
procedure write_real(r: real);

var
 k: vk;  i, j: integer;
 
begin
k.R := r;
write( chr( k.A[31] + ord('0') ) );
write('   ');

for i := 7 downto 0 do
 write( chr( k.A[i+23] + ord('0') ) );
write('   ');

write('1. ');

for i := 22 downto 0 do
 write( chr( k.A[i] + ord('0') ) );

writeln;
end;
}
 





function TenPower(Int: integer): real;

{-----------------------------------------------------------------------------
{
{ Abstract:
{
{     This function returns 10.0 raised to the power Int as a real number.
{
{ Parameters:
{
{     Int - the desired power of 10.0, with an allowed range -37..38.
{
{ Environment:
{
{     StrmNameF is a global variable which identifies the file
{     for reporting exceptions.
{
{ Returns:
{
{     The variable returned is of type real, and represents 10.0 raised to
{     the integer power Int.
{ 
{ Exceptions:
{
{     SmallReal - raised if the requested power of ten is too small to
{                   be represented by a 32-bit IEEE-Standard real number.
{
{     LargeReal - raised if the requested power of ten is too large to
{                   be represented by a 32-bit IEEE-Standard real number.
{
{ Design:
{
{     For each allowed value of Int there is a case element containing an
{     assignment statement, which assigns an octal constant to the type long
{     variant of temp.  This octal constant represents the bit pattern for
{     the real number 10.0**Int.  A case-otherwise raises the correct
{     exception for Int out of range.
{
{     An offset of 100 is added to Int to avoid case labels less than zero.
{
{-----------------------------------------------------------------------------}

var
 temp: vk;

begin

case Int+100 of
 {100-37}   63: temp.L := #00202016352;
 {100-36}   64: temp.L := #00352422045;
 {100-35}   65: temp.L := #00525126456;
 {100-34}   66: temp.L := #00701166075;
 {100-33}   67: temp.L := #01051423514;
 {100-32}   68: temp.L := #01223730437;
 {100-31}   69: temp.L := #01400347263;
 {100-30}   70: temp.L := #01550441140;
 {100-29}   71: temp.L := #01722551370;
 {100-28}   72: temp.L := #02077303666;
 {100-27}   73: temp.L := #02247472322;
 {100-26}   74: temp.L := #02421411006;
 {100-25}   75: temp.L := #02575713210;
 {100-24}   76: temp.L := #02746537025;
 {100-23}   77: temp.L := #03120266632;
 {100-22}   78: temp.L := #03274344401;
 {100-21}   79: temp.L := #03445616640;
 {100-20}   80: temp.L := #03617162410;
 {100-19}   81: temp.L := #03773017112;
 {100-18}   82: temp.L := #04144711357;
 {100-17}   83: temp.L := #04316073652;
 {100-16}   84: temp.L := #04471512625;
 {100-15}   85: temp.L := #04644016575;
 {100-14}   86: temp.L := #05015022334;
 {100-13}   87: temp.L := #05170227023;
 {100-12}   88: temp.L := #05343136314;
 {100-11}   89: temp.L := #05513765777;
 {100-10}   90: temp.L := #05666763377;
 {100-09}   91: temp.L := #06042270137;
 {100-08}   92: temp.L := #06212746167;
 {100-07}   93: temp.L := #06365537625;
 {100-06}   94: temp.L := #06541433675;
 {100-05}   95: temp.L := #06711742654;
 {100-04}   96: temp.L := #07064333427;
 {100-03}   97: temp.L := #07240611157;
 {100-02}   98: temp.L := #07410753412;
 {100-01}   99: temp.L := #07563146315;
 {100+00}  100: temp.L := #07740000000;
 {100+01}  101: temp.L := #10110000000;
 {100+02}  102: temp.L := #10262000000;
 {100+03}  103: temp.L := #10436400000;
 {100+04}  104: temp.L := #10607040000;
 {100+05}  105: temp.L := #10760650000;
 {100+06}  106: temp.L := #11135022000;
 {100+07}  107: temp.L := #11306113200;
 {100+08}  108: temp.L := #11457536040;
 {100+09}  109: temp.L := #11633465450;
 {100+10}  110: temp.L := #12005201371;
 {100+11}  111: temp.L := #12156441667;
 {100+12}  112: temp.L := #12332152245;
 {100+13}  113: temp.L := #12504302347;
 {100+14}  114: temp.L := #12655363041;
 {100+15}  115: temp.L := #13030657651;
 {100+16}  116: temp.L := #13203415712;
 {100+17}  117: temp.L := #13354321274;
 {100+18}  118: temp.L := #13527405553;
 {100+19}  119: temp.L := #13702543443;
 {100+20}  120: temp.L := #14053274354;
 {100+21}  121: temp.L := #14226153447;
 {100+22}  122: temp.L := #14401703170;
 {100+23}  123: temp.L := #14552264026;
 {100+24}  124: temp.L := #14724741034;
 {100+25}  125: temp.L := #15101054521;
 {100+26}  126: temp.L := #15251267646;
 {100+27}  127: temp.L := #15423545617;
 {100+28}  128: temp.L := #15600237471;
 {100+29}  129: temp.L := #15750307410;
 {100+30}  130: temp.L := #16122371312;
 {100+31}  131: temp.L := #16277067574;
 {100+32}  132: temp.L := #16447342656;
 {100+33}  133: temp.L := #16621233431;
 {100+34}  134: temp.L := #16775502337;
 {100+35}  135: temp.L := #17146411414;
 {100+36}  136: temp.L := #17320113716;
 {100+37}  137: temp.L := #17474136702;
 {100+38}  138: temp.L := #17645473231;

     otherwise: if Int < -37
                 then raise SmallReal(StrmNameF)
                 else raise LargeReal(StrmNameF);

end; {case}
TenPower := temp.R;
end;






function RealMul(x,y: real): real;

{-----------------------------------------------------------------------------
{
{ Abstract:
{
{     This function checks whether the multiplication of two real numbers
{     will cause underflow or overflow, and if so raises the exceptions
{     SmallReal and LargeReal respectively.  Otherwise, it allows the
{     micro-code to do the multiplication, and returns the result of this
{     multiplication.
{
{     This function relieves the program from depending on the micro-code
{     to report underflow and overflow conditions, and guarantees that
{     these conditions are reported by meaningful exceptions.
{
{ Parameters:
{
{     x - first operand of the multiplication.
{
{     y - second operand of the multiplication.
{
{ Environment:
{
{     StrmNameF is a global variable which identifies the file
{     for reporting exceptions.
{
{ Returns:
{
{     The variable returned is of type real, and represents the real
{     multiplication of the two operands supplied.
{
{ Exceptions:
{
{     SmallReal - raised if the result of the multiplication is too small
{                   to be represented by a 32-bit IEEE-Standard real number.
{
{     LargeReal - raised if the result of the multiplication is too large
{                   to be represented by a 32-bit IEEE-Standard real number.
{
{ Design:
{
{     The operands are copied into variables of type variant_kludge, and
{     there exponents extracted and substituted by the relative zero (i.e.,
{     zero + exp_bias).  These modified real numbers are then multiplied
{     and the exponent extracted from the result of the multiplication.
{     The sum of the three extracted exponents and the exponent bias is then
{     checked to be in the allowed range 1..254, and the appropriate
{     exception raised if the sum is outside this range.
{
{-----------------------------------------------------------------------------}

var
 p, q, r: vk;
 p_exp, q_exp, r_exp, exp: integer;
 
begin
p.R := x;
p_exp := LAnd(p.HW, #077777) div #200 - exp_bias;  {extract exponent}
p.HW := LOr( LAnd(p.HW, #100177), #037600 );  {assign 0 to exponent}

q.R := y;
q_exp := LAnd(q.HW, #077777) div #200 - exp_bias;  {extract exponent}
q.HW := LOr( LAnd(q.HW, #100177), #037600 );  {assign 0 to exponent}

r.R := p.R * q.R;
r_exp := LAnd(r.HW, #077777) div #200 - exp_bias;  {extract exponent}

exp := p_exp + q_exp + r_exp + exp_bias;

if exp <= 0
 then raise SmallReal(StrmNameF)
 else
 if exp >= 255
  then raise LargeReal(StrmNameF)
  else 
  RealMul := x * y;
end;






procedure ReadR(var F: FileType;
                var value: real);

{-----------------------------------------------------------------------------
{
{ Abstract:
{
{     This procedure reads a real number from the file F, and returns
{     its value.
{
{ Parameters:
{
{     F - identifies the file from which to read.
{
{     value - is a return parameter returning the value of the real number
{             read from the file F.
{
{ Results:
{
{     This procedure modifies the file buffer for F, and stores the value
{     of the real number in value.
{
{ Side Effects:
{
{     This procedure reads characters from the external file F, until it
{     receives a character which cannot be part of the real number, and it 
{     leaves this character in the file buffer.
{
{     There has been only minimal care taken with the file buffer, so if
{     an exception is raised during the read, there is no guarantee about
{     its contents.
{
{ Exceptions:
{
{     PastEof - raised if an attempt is made to read beyond the end of file.
{
{     NotReal - raised if the stream of characters in file F does not 
{               correspond to a real number.
{
{     SmallReal - raised if the number read is too small to be
{                   represented by a 32-bit IEEE-Standard real number.
{
{     LargeReal - raised if the number read is too large to be
{                   represented by a 32-bit IEEE-Standard real number.
{
{ Calls:
{
{     StreamName - in module Stream for the stream name of file F.
{
{     GetC - in module Stream for reading the next character from file F.
{
{     RealMul
{
{     TenPower - returns a real number representing 10.0 raised to an
{                integer (range -37..38) power.
{
{ Design:
{
{     The regular expression for real numbers is described by a DFA and
{     implemented by a case statement, where each element of the case
{     statement corresponds to a state in the DFA.  This case statement
{     stores information about the number read into (primarily) three
{     variables: 1) mant - a string buffer containing the mantissa,
{     2) scale_factor - any adjustment to the mantissa (as a power of ten),
{     and 3) exp - the exponent of the number read.
{
{     After the DFA has substringed out the mantissa characters, they
{     are converted to a real number by successive divisions by 10.0.
{
{     To combine this information into a real number, the scale_factor is
{     added to the exponent and this sum is the power of ten exponent of the
{     mantissa. To combine sum with the mantissa, it has to be converted to
{     a real number, which is done by the function TenPower.  Then the
{     result of TenPower is multiplied with the mantissa to produce the 
{     real number returned as value.
{
{     Much care has been taken to avoid calls to TenPower with actual
{     parameters which are out of range, and also to minimize the number
{     of real multiplications necessary (this to avoid error propogation).
{
{-----------------------------------------------------------------------------}

const
 max_exp  = 999;



var
 Ch: char;
 mant_sign_positive, exp_sign_positive: boolean;
 mant: vk;
 mant_exp: integer;
 mant_overflow: boolean;
 mant_buf: string;
 len_of_mantbuf: integer;
 
 exp: integer;
 exp_overflow: boolean;
 scale_factor: integer;

 state: integer;
 
 i, j: integer;


 
begin  {ReadR}

StrmNameF := StreamName(F);     { StrmNameF is global to module PasReal. }

with F, Flag do
   begin
      if not CharReady then GetC(F);
      if FEof then raise PastEof(StrmNameF);

      while (Element.C in [' ', Tab, FF]) and not FEof do   { Skip to 1st }
         begin                                              { interesting }  
            CharReady := False;                             { character.  }
            GetC(F)
         end;

      if FEof then raise PastEof(StrmNameF);

      mant_sign_positive := true;
      mant_buf:='';
      
      exp_sign_positive := true;
      exp := 0;
      exp_overflow := false;
  
      scale_factor := 0;
    
      state := 0;
    
      { The case labels correspond to the labelling of states in a  }
      { DFA for recognizing Pascal numbers, a graph of which I have.}
    
      repeat
         case state of
  

      { Enter the DFA. }
  
        0: begin
              if '+' = Element.C then state := 1
              else if '-' = Element.C then state := 2
              else if '0' = Element.C then state := 3
              else if ('1' <= Element.C) and (Element.C <= '9') then state := 4
              else state := 50;
           end;
    
 
      { Interpret the sign. }
  
        1: begin
              mant_sign_positive := true;
  
              CharReady := false;  GetC(F);
              if '0' = Element.C then state := 3
              else if ('1' <= Element.C) and (Element.C <= '9') then state := 4
              else state:=50;
           end;
       
        2: begin
              mant_sign_positive := false;
  
              CharReady := false;  GetC(F);
              if '0' = Element.C then state := 3
              else if ('1' <= Element.C) and (Element.C <= '9') then state := 4
              else state:=50;
           end;
       

      { Ignore leading zeroes on mantissa }

        3: begin
              CharReady := false;  GetC(F);
              if '0' = Element.C then state := 3
              else if ('1' <= Element.C) and (Element.C <= '9') then state := 4
              else if Element.C = '.' then state := 5
              else if Element.C in ['e', 'E'] then state := 7
              else state:=24;
           end;
       
  
      { Accumulate the mantissa into a string }
      
        4: begin
              AppendChar(mant_buf,Element.C);
              scale_factor := scale_factor + 1;
   
              CharReady := false;  GetC(F);
              if ('0' <= Element.C) and (Element.C <= '9') then state := 4
              else if Element.C = '.' then state := 5
              else if Element.C in ['e', 'E'] then state := 7
              else state:=25;
           end;
                      

      { Set up for the fractional part which should follow. }  

        5: begin
{$R-}
              len_of_mantbuf := ord(mant_buf[0]); { simulate length function }
{$R+}
              CharReady := false;  GetC(F);
              if ('0' <= Element.C) and (Element.C <= '9') then state := 6
              else state:=50;
           end;
  
  
      { Accumulate the fractional part also into the mantissa string }
    
        6: begin
              AppendChar(mant_buf,Element.C);
   
              CharReady := false;  GetC(F);
              if ('0' <= Element.C) and (Element.C <= '9') then state := 6
              else if Element.C in ['e', 'E'] then state := 7
              else state := 25;
           end;
  
            
      { Look for the start of an exponent. }
    
        7: begin
              CharReady := false;  GetC(F);
              if ('0' <= Element.C) and (Element.C <= '9') then state := 10
              else if '+' = Element.C then state := 8
              else if '-' = Element.C then state := 9
              else state:=50;
           end;
  
      { Interpret the sign. }
    
        8: begin
              exp_sign_positive := true;
              CharReady := false;  GetC(F);
              if ('0' <= Element.C) and (Element.C <= '9') then state := 10
              else state:=50;
           end;
  
        9: begin
              exp_sign_positive := false;
              CharReady := false;  GetC(F);
              if ('0' <= Element.C) and (Element.C <= '9') then state := 10
              else state:=50;
           end;
  
  
      { Accumulate the exponent in exp.  Check for overflow: it is an error. }
      { My choice of max_exp as 999 is somewhat arbitrary, but effective.   }  
  
        10:begin
              if not exp_overflow then
                 exp := (10 * exp) + (ord(Element.C) - ord ('0'));
              if exp > max_exp then
                 exp_overflow := true;  {raise exception later}
               
              CharReady := false;  GetC(F);
              if ('0' <= Element.C) and (Element.C <= '9') then state := 10
              else state := 25;
           end;
  
  
      { All we saw was leading mantissa zeroes so fake it }
    
        24: begin
               mant_buf:='0';
               mant_sign_positive:=true;
               exp:=0;
               exp_sign_positive:=true;
               exp_overflow := false;
               scale_factor:=0;
               state := 25;
            end;
       
      { Error state -- fake a zero for later stuff }
    
        50: begin
               raise NotReal(StrmNameF);
               mant_buf:='0';
               mant_sign_positive:=true;
               exp:=0;
               exp_sign_positive:=true;
               exp_overflow := false;
               scale_factor:=0;
               state := 25;
            end;
       
         end; {case}
      until state = 25;  {exit DFA}

      { convert the string into a real number(with appropriate exponent) }

      mant.L := 0;
{$R-}
      len_of_mantbuf := ord(mant_buf[0]); { simulate length function }
{$R+}
    
      for i := 1 to len_of_mantbuf do
         begin
            j := ord(mant_buf[len_of_mantbuf-i+1]) - ord('0');
            mant.R := (mant.R + float(j))/10.0;
         end;
    
      if not exp_sign_positive then exp := -exp;  {negate exponent}
  
      if exp_overflow then
         if exp_sign_positive
            then raise LargeReal(StrmNameF)
            else raise SmallReal(StrmNameF);
      
      if mant.L = 0 then
         value := mant.R
      else
         if (-37 <= exp+scale_factor) and (exp+scale_factor <= +38) then
            value := RealMul( mant.R, TenPower(exp+scale_factor) )
         else
           if (-37 <= exp) and (exp <= +38)
          and (-37 <= scale_factor) and (scale_factor <= +38) then
              value := RealMul(mant.R * TenPower(scale_factor), TenPower(exp))
           else
              if (-45 <= exp) and (exp <= -38)
             and (-37 <= scale_factor) and (scale_factor <= +38) then
                value := RealMul(RealMul( mant.R * TenPower(exp+37),
                                         TenPower(scale_factor) ),
                                 TenPower(-37))
             else
                raise LargeReal(StrmNameF);
         
      if not mant_sign_positive then value := -value;  {negate mantissa}
  
   end; {with}
end;  {ReadR}




procedure WriteR(var F: FileType;
                     e: real;
                     TotalWidth: integer;
                     FracDigits: integer;
                     format: integer);
{-----------------------------------------------------------------------------
{
{ Abstract:
{
{     This procedure writes a real number to a file F, under the
{     given format specifications.
{
{ Parameters:
{
{     F - the file to which to write.
{
{     e - the value to write.
{
{     TotalWidth - the minimum number of characters to write.
{
{     FracDigits - the number of characters in the fractional part (used for
{                  fixed format only).
{
{     format - indicates either fixed or floating format.
{
{ Results:
{
{     The file buffer for F is modified by procedures nested in this one.
{
{ Calls:
{
{     StreamName - in module Stream for the stream name of file F.
{
{     real_to_string
{
{     fixed_format_specification
{  or float_format_specification
{
{ Design:
{
{     There is some initialization, then if the real number to be written
{     is zero, eWritten and ExpValue are obviously zero, else the real 
{     number needs to be converted to base 10 giving eWritten and ExpValue.
{     Then a call is made to a procedure for the desired format.
{
{     The design here follows as much as possible the ISO Standard 
{     description for writing Pascal real numbers, in particular, the choice
{     of many variable names.
{
{-----------------------------------------------------------------------------}

const
 fixed    = 1;
 floating = 0;
 
 ExpDigits = 2;      {used in floating point write}
 LeadBlanks = 2;     {used in floating point write}

type
 str_10_chars = packed array[1..10] of char;
  
var
 ActWidth: integer;        { These variables are  }
 eWritten: str_10_chars;   { taken from the       }
 ExpValue: integer;        { description given in }
                           { the ISO Standard for }
 IntDigits: integer;       { fixed and floating   }
 MinNumChars: integer;     { point write.         }
  
 last_digit: integer;

 k, zero : vk;
 except_occurred: boolean;

procedure real_to_string (r : real; var s : str_10_chars; var E10 : integer);

{-----------------------------------------------------------------------------
{
{ Abstract:
{
{     This procedure converts a non-zero real number in base 2 to
{     a pair of variables which represent the number in base 10.
{
{ Parameters:
{
{     r - the non-zero real number to be converted.
{
{ Environment:
{
{     Internal to WriteR.
{
{ Results:
{
{     s   - a 10-digit string in the range '1000000000' to '9999999999'.
{
{     E10 - the power of 10 associated with s / 10**9.
{
{ Exceptions:
{
{     SmallReal - raised if the number is too small to be
{                   represented by a 32-bit IEEE-Standard real number.
{
{     LargeReal - raised if the number is too large to be
{                   represented by a 32-bit IEEE-Standard real number.
{
{ Calls:
{
{     Internal procedures Upscale, Downscale and NormG only.
{
{ Design:
{
{     Replace the exponent with Bias + 23, and convert the resultant real
{     to a 24-bit long integer MR. Note in bexp the power of 2 to be applied. 
{
{     Using another long integer MG as a guard digit (actually 4 digits),
{     operate on MR_MG in integer arithmetic with powers of 2 counted out
{     of bexp, and powers of 10 counted into dexp, until bexp is zero.
{
{     Convert MR_MG to a rounded 10-digit string s, and correct dexp by 7
{     as an implicit scaling of s into 1.0 <= M10 < 10.0.
{
{     An 8-digit result constructed by further rounding will have a maximum
{     error of 0.505 in its last digit, which is regarded as acceptable.
{     9-digit results would be phoney anyway, so their maximum error of
{     0.55 in the last digit is happily irrelevant.
{
{     The problem with the real result, in the range 1.0 <= e < 10.0, given
{     by the previous version of this routine was firstly the cumulative
{     errors introduced by successive real arithmetic operations to create
{     it, secondly the hazardous nature of adding 0.0...05 to it to round
{     it in a desired digit position, and finally that in real arithmetic
{     (a.bcdefgh - a.0000000) * 10.0 is not quite b.cdefgh0, so that real
{     approximations accumulated during its conversion to a character string.
{     In the new version, integer arithmetic is used to give exact results
{     from the earliest possible stage.
{
{-----------------------------------------------------------------------------}

var bexp, dexp, ib, d1, d2, i : integer;
    MR, Mmax, Mmin, MG, c, lb, t : long;
    k : vk;
    too_small, too_large : string;

    procedure normg; { normalise guard digit }
    begin MG := MG - lb;
          MR := MR + 1
    end;

    procedure upscale;
    begin  c := MG * 10;
          MG := c mod lb;
          MR := MR*10 + c div lb;
          dexp := dexp - 1
    end;

    procedure downscale;
    begin  c := MR mod 10; MR := MR div 10;
          MG := MG + c*lb;  t := MG mod 20; { divide by 10, round to even }
          if t >= 15 then MG := MG - t + 20 else
          if t  >  5 then MG := MG - t + 10 else
                          MG := MG - t;
          MG := MG div 10; if MG >= lb then normg; dexp := dexp+1
    end;

begin k.R := r;
      bexp := shift (land(k.HW, #077600), -7);
      if bexp = 0 then
      begin raise RealWriteError(StrmNameF);
            too_small := ' *too_small_real';
            for i := 1 to length(too_small) do
            with F.Element do
            begin C := too_small[i];  PutC(F)
            end; except_occurred := true
      end   else if bexp = 255 then
      begin raise RealWriteError(StrmNameF);
            too_large := ' *too_large_real';
            for i := 1 to length(too_large) do
            with F.Element do
            begin C := too_large[i];  PutC(F)
            end; except_occurred := true
      end   else
      begin bexp := bexp - 127 - 23;
            k.HW := lor (land(k.HW, #177), shift (127+23, 7));

          { k.R is now an integer in the range 8.4e+6 to 1.7e+7 approx,
            to be multiplied by 2**bexp. First, convert it to an exact
            24-bit integer MR, either by Q-code ROPS.XRND or thus :- }
      
            ib := 10000; { or any similar integer }
            d1 := trunc (k.R / float (ib));
            d2 := round (k.R - float(d1)*float(ib));
            MR := stretch(d1)*stretch(ib) + stretch(d2);
      
            Mmax := 16777215; { to allow MR*128. Mmin is 16777222 }
            MG := 0; lb := 10000; dexp := 0;
          { MG is the guard "digit", from 0 to 9999 }
      
            while bexp > 10 do { MR,MG := MR,MG * 1024 / 1000 }
            begin  c := MG * 128; MG := c mod lb;
                  MR := MR * 128 + c div lb;
                   c := MR mod 125; MR := MR div 125;
                  MG := (MG + c*lb + 62) div 125;
                  if MG >= lb then normg;
                  bexp := bexp - 10; dexp := dexp + 3;
                  if MR > Mmax then downscale
            end;

            Mmin := 1717986; { to allow upscale and MR*125 }
            while bexp < -10 do { MR,MG := MR,MG * 1000 / 1024 }
            begin  c := MG * 125; MG := c mod lb;
                  MR := MR * 125 + c div lb;
                   c := MR mod 128; MR := MR div 128;
                  MG := MG + c * lb; t := MG mod 256;
                  if t >= 192 then MG := MG - t + 256 else
                  if t  >  64 then MG := MG - t + 128 else
                                   MG := MG - t;
                  MG := MG div 128; if MG >= lb then normg;
                  bexp := bexp + 10; dexp := dexp - 3;
                  if MR < Mmin then upscale
            end;

            Mmax := 99999999;
            Mmin := 10000000;
            while bexp > 0 do
            begin MR := MR + MR;
                  MG := MG + MG;
                  if MG >= lb then normg;
                  bexp := bexp - 1;
                  if MR > Mmax then downscale
            end;
            while bexp < 0 do
            begin  c := MR mod 2; MR := MR div 2;
                  MG := MG + c * lb; t := MG mod 4;
                  if t = 3 then MG := MG + 1 else
                  if t = 1 then MG := MG - 1;
                  MG := MG div 2; if MG >= lb then normg;
                  bexp := bexp + 1;
                  if MR < Mmin then upscale
            end;
            
          { MR is not necessarily 8 decimal digits yet }

            if MR < Mmin then upscale;

          { Now convert to rounded 10-digit string }

            t := MG mod 200;
            if t >= 150 then MG := MG - t + 200 else
            if t  >  50 then MG := MG - t + 100 else
                             MG := MG - t;
            if MG >= lb then normg; if MR > Mmax then downscale;
            
            for i := 8 downto 1 do
            begin s[i] := chr (shrink(MR mod 10) + ord_zero);
                  MR := MR div 10
            end;  MG := MG div 100;
            s[10] := chr (shrink(MG mod 10) + ord_zero);
            s[ 9] := chr (shrink(MG div 10) + ord_zero);

            E10 := dexp + 7
end   end; {real_to_string}

procedure round_off (pos : integer);

{-----------------------------------------------------------------------------
{
{ Abstract:
{
{     This procedure rounds off the string eWritten in its `pos`th digit.
{     When rounding carries out of eWritten[1], it correctly resets the
{     string to '10...0' and adjusts ExpValue by 1.
{
{ Environment:
{
{     Internal to WriteR.
{
{     This procedure expects that the number to be written is stored in
{     the pair of global variables eWritten and ExpValue, and that pos
{     is in the range 1 to 8; pos = 9 works, but is a bit silly.
{
{ Side Effects:
{
{     eWritten and ExpValue may be modified. The digits of eWritten
{     below eWritten[pos] are not predictable (this is to allow for
{     possible future variants of this routine).
{
{----------------------------------------------------------------------------}

var i : integer; round_up, exact_half : Boolean;

begin if eWritten[pos+1] > '5' then round_up := true  else
      if eWritten[pos+1] < '5' then round_up := false else
      begin exact_half := true; for i := pos+2 to 10 do
            exact_half := exact_half and (eWritten[i] = '0');
         if exact_half then round_up := odd (ord(eWritten[pos]) - ord_zero)
                       else round_up := true { greater than exact half }
      end;

      for i := pos+1 to 10 do eWritten[i] := '*'; { diagnostic trap }

      while round_up and (pos > 0) do
      begin if eWritten[pos] = '9' then eWritten[pos] := '0' else
            begin round_up := false;
                  eWritten[pos] := chr (ord (eWritten[pos]) + 1)
            end;  pos := pos - 1
      end;  if round_up { and (pos = 0) } then
      begin eWritten := '1000000000';
            ExpValue := ExpValue + 1   { not ... ExpValue - 1 }
end   end; {round_off}

procedure fixed_format_specification;

{-----------------------------------------------------------------------------
{
{ Abstract:
{
{     This procedure writes the pair of variables which represent
{     the base 2 real number, using the fixed format specifications.
{
{ Environment:
{
{     Internal to WriteR.
{
{     This procedure expects that the number to be written is stored in
{     the pair of global variables eWritten and ExpValue, and that eWritten
{     is normalized. 
{
{ Side Effects:
{
{     A sequence of characters corresponding to the real number represented
{     by the pair of variables eWritten and ExpValue is output to the file F.
{
{ Calls:
{
{     RoundOff
{
{     PutC - writes a character to the specified file (in module Stream).
{
{ Design:
{
{     The digit string eWritten is rounded in the last digit to be written,
{     and written to the file F with TotalWidth - MinNumChars blanks, the
{     digits which are the integer part of the number, a decimal point, and
{     FracDigits fractional digits.
{
{     The design here follows as much as possible the ISO Standard 
{     description for writing Pascal real numbers, in particular, the choice
{     of many variable names.
{
{-----------------------------------------------------------------------------}

var
 i, j: integer;

begin

if FracDigits < 1 then FracDigits := 1;

if (e <> zero.R) then
 {round in the last digit to be written }
 begin
 last_digit := FracDigits + 1 + ExpValue;   { not ... + 1 - ExpValue }
 if last_digit = 0 then   { special case for heavier rounding off }
  begin
  if eWritten[1] >= '5' then
   begin eWritten[1] := '1'; ExpValue := ExpValue + 1
   end   else eWritten[1] := '*';
  for i := 2 to 10 do eWritten[i] := '*'    { diagnostic trap, ctd. }
  end else
  begin
  if last_digit > 8 then last_digit := 8;
  if last_digit < 1 then last_digit := 1;
  round_off (last_digit)
  end
 end;
 
if ExpValue < 1 
 then IntDigits := 1
 else IntDigits := ExpValue + 1;
 
MinNumChars := IntDigits + FracDigits + 1;
if (e < zero.R) then MinNumChars := MinNumChars + 1;

with F.Element do
 begin
 C := ' ';
 for i := 1 to TotalWidth-MinNumChars do PutC(F);
 
 if e < zero.R then  begin  C := '-';  PutC(F);  end;
 
 if ExpValue < 0 then
  begin
  C := '0';  PutC(F);
  C := '.';  PutC(F);

  C := '0';
  for i := ExpValue to -2 do 
   if FracDigits > 0 then
    begin 
    PutC(F);
    FracDigits := FracDigits - 1;
    end;

  for i := 1 to FracDigits do
   begin
   if i <= 8 
    then C := eWritten[i]
    else C := '0';
   PutC(F);
   end;
  end

  else begin
  for i := 1 to IntDigits do
   begin 
   if i <= 8 
    then C := eWritten[i]
    else C := '0';
   PutC(F);
   j := i;
   end;

  C := '.';  PutC(F);

  for i := 1 to FracDigits do
   begin 
   if j+i <= 8 
    then C := eWritten[j+i]
    else C := '0';
   PutC(F);
   end;
  end;
 end; {with}
end;

procedure float_format_specification;

{-----------------------------------------------------------------------------
{
{ Abstract:
{
{     This procedure writes the pair of variables which represent
{     the base 2 real number, using the floating format specifications.
{
{ Environment:
{
{     Internal to WriteR.
{
{     This procedure expects that the number to be written is stored in
{     the pair of global variables eWritten and ExpValue, and that eWritten
{     is normalized. 
{
{ Side Effects:
{
{     A sequence of characters corresponding to the real number represented
{     by the pair of variables eWritten and ExpValue is output to the file F.
{
{ Calls:
{
{     RoundOff
{
{     PutC - writes a character to the specified file (in module Stream).
{
{ Design:
{
{     The digit string eWritten is rounded in the eighth digit,
{     normalized again, and written to the file F with
{     one digit before the decimal point, a sequence 
{     after the decimal point, and an exponent.
{
{     The design here follows as much as possible the ISO Standard 
{     description for writing Pascal real numbers, in particular, the choice
{     of many variable names.
{
{     This design deviates from the ISO Standard in that it prefixes each 
{     number written with two blanks.
{
{-----------------------------------------------------------------------------}

var
 i: integer;
 zero_fill: integer;
 
begin

if TotalWidth >= ExpDigits + 6 + LeadBlanks     {ActWidth for floating write}
 then ActWidth := TotalWidth    
 else ActWidth := ExpDigits + 6 + LeadBlanks;

if (e <> zero.R) then
 {round the last digit to be written }
 begin
 last_digit := ActWidth - LeadBlanks - ExpDigits - 4;
 if last_digit > 8 then last_digit := 8;
 round_off (last_digit)
 end;

with F.Element do
 begin
 C := ' ';  PutC(F);  PutC(F);     { Deviation from ISO Standard. }
 
 if e < 0 then C := '-';  PutC(F);
 
 C := eWritten[1];  PutC(F);
 C := '.';  PutC(F);

 zero_fill := 0;
 if ActWidth > 16 then
  begin
  zero_fill := ActWidth - 16;
  ActWidth := 16;
  end;
  
 for i := 1 to ActWidth-ExpDigits-7 do  {(ActWidth-2)-ExpDigits-5}
  begin
  C := eWritten[i+1];  PutC(F);
  end;

 C := '0';
 for i := 1 to zero_fill do PutC(F);
 
 C := 'e';  PutC(F);
 if ExpValue < 0 then C := '-' else C := '+';  PutC(F);
 C := chr((abs(ExpValue) div 10) + ord_zero);  PutC(F);
 C := chr((abs(ExpValue) mod 10) + ord_zero);  PutC(F);
 end;
end;

begin {WriteR}

      StrmNameF := StreamName(F);  { StrmNameF is global to module PasReal. }
      except_occurred := false;

      zero.L     := #00000000000;

      if (e = zero.R) then
      begin eWritten := '0000000000';
            ExpValue := 0
      end   else
      real_to_string(abs(e), eWritten, ExpValue);

      if not except_occurred then 
      CASE format OF
      fixed:    fixed_format_specification;
      floating: float_format_specification END

end. {WriteR}
