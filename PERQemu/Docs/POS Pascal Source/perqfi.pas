{---------------------------------------------------------------------
{ Copyright (C) 1983 - Perq Systems Corporation.
{---------------------------------------------------------------------}
program PerqFiles;

{     Perq.Files - make command files for system floppys.
                   J. P. Strait     22 Aug 80.
                   Copyright (c) Three Rivers Computer Corporation 1980.
      
      See Help entry for documentation.
      
      Change log.
      
      29 Apr 82  V1.5  E. Colwell      1) Changed line generated by link
                                          command so that it conforms to
                                          current interface.
                                          
      27 Apr 82  V1.4  E. Colwell      1) Took out the sides and density stuff
      
       4 Mar 81  V1.3  J. Strait       1) Change command line processing to
                                          have two file names: input file and
                                          transcript file.
                                       2) Add COPY command.
                                       3) Add path names.
                                       4) Convert to new operating system.
                                       5) Add HELP command.
                                       6) Add QUIT command.
                                       7) Use CmdParse for commands.
                                       8) Add PLXVERIFY command.
                                       9) Add COMPARE command.
                                       
      20 Oct 80  V1.2  J. Strait       Put a big loop around everything to
                                       allow generation of several command
                                       files in a single run.
                                       
      17 Sep 80  V1.1  J. Strait       Add 'LINK' command.
                                       Ask date, sides, and density for PLX.
}


 imports CmdParse from CmdParse;
 imports System from System;
 imports Perq_String from Perq_String;
 imports Clock from Clock;


const PerqFVersion = '1.5';
      MaxClasses = 40;
      
      HelpC = 1;
      ListC = 2;
      PLXGetC = 3;
      PLXPutC = 4;
      PLXVerifyC = 5;
      FTPGetC = 6;
      FTPPutC = 7;
      LinkC = 8;
      CopyC = 9;
      CompareC = 10;
      QuitC = 11;
      NumCmds = 11;
      NotUnique = NumCmds + 1;
      NotFound = NumCmds + 2;
      

var CmdFileName, Line, Ignore: String;
    CommandFile, PerqF, Transcript: Text;
    Name: CmdArray;
    NameCount: integer;
    ClassTable: array[1..MaxClasses] of record
                 First, Middle, Last: integer;
                 Comment: String;
                 Desired: boolean
                end;
    ClassCount, CurrentClass: integer;
    Date, Sides, Density: String;
    ReadingInFile, WritingTranscriptFile, FirstTimeThrough, FirstPlx: Boolean;
    SrcPath, DstPath, OnlyPath: String;
    InFileName, OutFileName: String;
    Commands: CmdArray;
    Cmd: Integer;
    

 procedure GetCommand;
 var Temp, ClassName: String;
     ReadingCommandLine, Error: Boolean;
 
 
  procedure Help;
  var I: integer;
  
  
   procedure W( S: String );
   begin { W }
    Writeln(S)
   end { W };
   
   
  begin { Help }
   W('');
   W('');
   W('  The Perq.Files program is used to:');
   W('');
   W('    1) List portions of the Perq.Files text file');
   W('    2) Make command files to create or extract files from the');
   W('       system backup floppys by making PLX command files to get');
   W('       files from the floppy or put files onto the floppy.');
   W('    3) Make command files to move system files from Perq to Perq.');
   W('    4) Make command files to link programs.');
   W('    5) Make command files to copy programs between partitions or');
   W('       directories.');
   W('    6) Make command files to compare programs between partitions');
   W('       or directories.');
   W('    7) Make command files to verify files using PLX.');
   W('');
   W('  System backup floppys are divided into classes which are');
   W('  defined by the text file Perq.Files.  For example, all the');
   W('  sources of system modules are in the class called OS.SOURCE.');
   W('');
   W('  Command form:');
   W('');
   W('    Perq.Files <InFile> <OutFile>');
   W('');
   W('       <InFile> is the name of the file from which Perq.Files');
   W('       commands are read--if absent, commands are read from the');
   W('       console.');
   W('');
   W('       <OutFile> is the name of the file to which a transcript is');
   W('       written.  This transcript may be used later as an input');
   W('       file.');
   W('');
   W('');
   W('  When reading from the console, Perq.Files prompts you with the');
   W('  following questions.');
   W('');
   W('  Command:');
   W('       Command chosen from the following list:');
   W('');
   W('       List      - list the entries.');
   W('       PLXGet    - get files from the floppy.');
   W('       PLXPut    - put files to the floppy.');
   W('       PLXVerify - verify files on the floppy.');
   W('       FTPGet    - get files from another Perq.');
   W('       FTPPut    - put files to another Perq.');
   W('       Link      - link programs in the class.');
   W('       Copy      - copy files between partitions or directories.');
   W('       Compare   - compare files between partitions or directories.');
   W('       Quit      - leave Perq.Files.');
   W('');
   W('  Output command file name:');
   W('       Name of file to write the PLX commands onto.');
   W('');
   W('  Path name:');
   W('       Path name to use for disk files for PLX and Link commands.');
   W('');
   W('  Source path name:');
   W('       Path name to use for source files for FTP, COPY, and Compare');
   W('       commands.');
   W('');
   W('  Destination path name:');
   W('       Path name to use for destination files for FTP, COPY, and');
   W('       Compare commands.');
   W('');
   W('  Class name:');
   W('       Name of a class to be included, chosen from the');
   W('       following list.  Uniquely abbreviated names are');
   W('       acceptable, and an asterisk matches any name in');
   W('       a certain position.  This question is asked repeatedly');
   W('       until an empty line is entered.  All classes listed will');
   W('       be included in a single command file.');
   Writeln;
   for I := 1 to ClassCount do
    with ClassTable[I] do
     begin Write('              ', Name[First]);
      if Middle <> 0 then
       begin Write('.', Name[Middle]);
        if Last <> 0 then
         Write('.', Name[Last])
       end;
      if Comment <> '' then
       Write(' - ', Comment);
      Writeln
     end;
   Writeln;
   Writeln
  end { Help };
  
  
  procedure GetWord( var Result: String; Question, Default: String);
  begin { GetWord }
   Write(Question);
   if Default <> '' then Write(' [', Default, ']');
   Write(': ');
   Readln(Result);
   if Result = '' then Result := Default;
   if ReadingInFile then Writeln(Result);
   if WritingTranscriptFile then Writeln(Transcript,Result);
   CnvUpper(Result)
  end { GetWord };
  
  
  procedure NewName;
  var C, FS, MS, LS: String;
      Class, FI, MI, LI: integer;
      Found: boolean;
  begin { NewName }
   C := ClassName;
   repeat
    RemDelimiters(C,' ',Ignore);
    GetSymbol(C,FS,'. ',Ignore);
    RemDelimiters(C,'.',Ignore);
    GetSymbol(C,MS,'. ',Ignore);
    RemDelimiters(C,'.',Ignore);
    GetSymbol(C,LS,' ',Ignore);
    if FS = '' then FI := 0
    else
     if FS = '*' then FI := -1
     else FI := UniqueCmdIndex(FS,Name,NameCount);
    if MS = '' then MI := 0
    else
     if MS = '*' then MI := -1
     else MI := UniqueCmdIndex(MS,Name,NameCount);
    if LS = '' then LI := 0
    else
     if LS = '*' then LI := -1
     else LI := UniqueCmdIndex(LS,Name,NameCount);
    Found := false;
    for Class := 1 to ClassCount do
     with ClassTable[Class] do
      if ((First = FI) or (FI = -1)) and
         ((Middle = MI) or (MI = -1)) and
         ((Last = LI) or (LI = -1)) then
       begin Desired := true; Found := true end;
    if not Found then
     begin Write(' class "', FS);
      if MS <> '' then
       begin Write('.',MS);
        if LS <> '' then
         Write('.',LS)
       end;
      Write('" not ');
      if (FI > NameCount+1) or (MI > NameCount+1) or (LI > NameCount+1) then
       Write('unique')
      else
       Write('found');
      Writeln;
      GetWord(C,'Class name','')
     end;
   until Found or (C = '')
  end { NewName };
  
  
 begin { GetCommand }
  for CurrentClass := 1 to MaxClasses do
   ClassTable[CurrentClass].Desired := false;
  Writeln;
  Writeln;
  repeat
   GetWord(Temp,'Command','Help');
   Cmd := UniqueCmdIndex(Temp,Commands,NumCmds);
   Error := (Cmd = HelpC) or (Cmd > NumCmds);
   if Error then
    if Cmd = HelpC then Help
    else
     begin
      if Cmd = NotUnique then Write(' non-unique')
      else Write(' unknown');
      Writeln(' command "', Temp, '"')
     end
  until not Error;
  if Cmd = QuitC then Exit(GetCommand);
  if (Cmd in [PLXGetC, PLXPutC, PLXVerifyC]) and FirstPlx then
   begin FirstPlx := false;
   end;
  if Cmd in [PLXGetC, PLXPutC, PLXVerifyC, LinkC] then
   GetWord(OnlyPath,'Path name',OnlyPath)
  else
   if Cmd in [FTPPutC, FTPGetC, CopyC, CompareC] then
    begin GetWord(SrcPath,'Source path name',SrcPath);
     GetWord(DstPath,'Destination path name',DstPath)
    end;
  GetWord(CmdFileName,'Output command file name','');
  repeat GetWord(ClassName,'Class name','');
   if ClassName <> '' then NewName
  until ClassName = ''
 end { GetCommand };
  
      
 procedure GobbleLine(Line: String; var F, M, L, Comment: String);
 begin { GobbleLine }
  RemDelimiters(Line,'> ',Ignore);
  GetSymbol(Line,F,'. ',Ignore);
  RemDelimiters(Line,'.',Ignore);
  GetSymbol(Line,M,'. ',Ignore);
  RemDelimiters(Line,'.',Ignore);
  GetSymbol(Line,L,'. ',Ignore);
  RemDelimiters(Line,'- ',Ignore);
  Comment := Line
 end { GobbleLine };
 
 
 procedure PreScanPerqF;
 var F, M, L: String;
     
     
  procedure NewName(N: String; var Index: integer);
  begin { NewName }
   if N = '' then Index := 0
   else
    begin Index := UniqueCmdIndex(N,Name,NameCount);
     if Index > NameCount then
      begin NameCount := NameCount + 1;
       if NameCount > MaxCmds then
        begin Writeln(' too many names in file Perq.Files.');
         Exit(PerqFiles)
        end;
       Index := NameCount;
       Name[NameCount] := N
      end
    end
  end { NewName };
  
  
 begin { PreScanPerqF }
  NameCount := 0;
  ClassCount := 0;
  while (PerqF^ <> '>') and not Eof(PerqF) do Readln(PerqF);
  while not Eof(PerqF) do
   begin ClassCount := ClassCount + 1;
    if ClassCount > MaxClasses then
     begin Writeln(' too many classes in Perq.Files.');
      Exit(PerqFiles)
     end;
    Readln(PerqF,Line);
    with ClassTable[ClassCount] do
     begin GobbleLine(Line,F,M,L,Comment);
      NewName(F,First);
      NewName(M,Middle);
      NewName(L,Last);
      Desired := false
     end;
    while (PerqF^ <> '>') and not Eof(PerqF) do Readln(PerqF)
   end
 end { PreScanPerqF };
 
 
 procedure CreateCommands;
 var DiskName, FloppyName, Version, Comment, Left, Right, Ignore: String;
 
 
  procedure WriteNames( LeftPath, LeftName, RightPath, RightName: String );
  begin { WriteNames }
   Write(CommandFile, LeftPath, LeftName);
   if Length(LeftName) < 20 then
    Write(CommandFile, ' ':20 - Length(LeftName));
   Write(CommandFile, ' ', RightPath, RightName)
  end { WriteNames };
 
 
 begin { CreateCommands }
  if Line <> '' then
   if Line[1] = '>' then Delete(Line,1,1);
  Line := Concat('! ', Line);
  Writeln(CommandFile);
  Writeln(CommandFile);
  Writeln(CommandFile,Line);   { create a comment on the file }
  Writeln(CommandFile,'! Created ',Date);
  Writeln(CommandFile);
  while (PerqF^ = ' ') and not Eof(PerqF) do Readln(PerqF);
  while (PerqF^ <> ' ') and not Eof(PerqF) do Readln(PerqF);
  while (PerqF^ = ' ') and not Eof(PerqF) do Readln(PerqF);
  while (PerqF^ <> '>') and not Eof(PerqF) do
   begin Readln(PerqF,Line);
    if Length(Line) < 10 then DiskName := '          '
    else DiskName := SubStr(Line,1,10);
    if DiskName <> '          ' then
     begin
      CnvUpper(DiskName);
      RemDelimiters(Line,' ',Ignore);
      GetSymbol(Line,DiskName,' ',Ignore);
      RemDelimiters(Line,' ',Ignore);
      GetSymbol(Line,Version,' ',Ignore);
      RemDelimiters(Line,' ',Ignore);
      GetSymbol(Line,FloppyName,' ',Ignore);
      if DiskName = ':LINK' then
       begin
        if Cmd = LinkC then
         begin
          GetSymbol(FloppyName,Left,'~',Ignore);
          Delete(FloppyName,1,1);
          Right := FloppyName;
          Write(CommandFile, 'Link ', OnlyPath, Left);
          if Right <> '' then Write(CommandFile, ' ~', OnlyPath, Right);
          Writeln(CommandFile)
         end
       end
      else
       if Cmd in [FTPGetC, FTPPutC] then
        begin
         Write(CommandFile,'FTP ');
         if Cmd = FTPGetC then Write(CommandFile, 'Get ')
         else { Put } Write(CommandFile, 'Put ');
         WriteNames(SrcPath, DiskName, DstPath, DiskName);
         Writeln(CommandFile)
        end
       else
        if Cmd in [PLXGetC, PLXPutC, PLXVerifyC] then
         if Cmd = PLXGetC then
          begin
           Write(CommandFile, 'Get ');
           WriteNames('', FloppyName, OnlyPath, DiskName);
           Writeln(CommandFile)
          end
         else { Put or Verify }
          begin
           if Cmd = PLXPutC then Write(CommandFile, 'Put ')
           else { Verify} Write(CommandFile, 'Verify ');
           WriteNames(OnlyPath, DiskName, '', FloppyName);
           Writeln(CommandFile)
          end
        else
         if Cmd = CopyC then
          begin
           Write(CommandFile, 'Copy ');
           WriteNames(SrcPath, DiskName, DstPath, DiskName);
           Writeln(CommandFile)
          end
         else
          if Cmd = CompareC then
           begin
            Write(CommandFile, 'Compare ');
            WriteNames(SrcPath, DiskName, DstPath, DiskName);
            Writeln(CommandFile)
           end
     end
   end
 end { CreateCommands };
 
 
 procedure List;
 begin { List }
  Writeln(CommandFile,Line);
  while (PerqF^ <> '>') and not Eof(PerqF) do
   begin Readln(PerqF,Line);
    Writeln(CommandFile,Line)
   end
 end { List };
 
 
 procedure Initialize;
 begin { Initialize }
  Reset(Input,'');
  Rewrite(Output,'');
  Writeln('Perq.Files ', PerqFVersion, '    type Help if you need it.');
  Reset(PerqF,'Perq.Files');
  RemDelimiters(UsrCmdLine,' ',Ignore);
  GetSymbol(UsrCmdLine,Ignore,' ',Ignore);   { skip "Perq.Files" }
  RemDelimiters(UsrCmdLine,' ',Ignore);
  GetSymbol(UsrCmdLine,InFileName,' ',Ignore);
  RemDelimiters(UsrCmdLine,' ',Ignore);
  GetSymbol(UsrCmdLine,OutFileName,' ',Ignore);
  ConvUpper(InFileName);
  ReadingInFile := (InFileName <> '') and (InFileName <> 'CONSOLE:');
  if ReadingInFile then Reset(Input,InFileName);
  WritingTranscript := OutFileName <> '';
  if WritingTranscript then Rewrite(Transcript,OutFileName);
  PreScanPerqF;
  Close(PerqF);
  FirstTimeThrough := true;
  FirstPlx := true;
  SrcPath := '';
  DstPath := '';
  OnlyPath := '';
  GetTString(Date);
  Commands[HelpC     ] := 'HELP';
  Commands[ListC     ] := 'LIST';
  Commands[PLXGetC   ] := 'PLXGET';
  Commands[PLXPutC   ] := 'PLXPUT';
  Commands[PLXVerifyC] := 'PLXVERIFY';
  Commands[FTPGetC   ] := 'FTPGET';
  Commands[FTPPutC   ] := 'FTPPUT';
  Commands[LinkC     ] := 'LINK';
  Commands[CopyC     ] := 'COPY';
  Commands[CompareC  ] := 'COMPARE';
  Commands[QuitC     ] := 'QUIT';
 end { Initialize };
 
 
begin { PerqFiles }
 Initialize;
 repeat
  GetCommand;
  if Cmd <> QuitC then
   begin Rewrite(CommandFile,CmdFileName);
    Reset(PerqF,'Perq.Files');
    for CurrentClass := 1 to ClassCount do
     begin
      while (PerqF^ <> '>') and not Eof(PerqF) do Readln(PerqF);
      Readln(PerqF,Line);
      if ClassTable[CurrentClass].Desired then
       if Cmd = ListC then List
       else CreateCommands
     end;
    Close(CommandFile);
    FirstTimeThrough := false
   end
 until Cmd = QuitC;
 Close(PerqF);
 if WritingTranscript then Close(Transcript)
end { PerqFiles }.
