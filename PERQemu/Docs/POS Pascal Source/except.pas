{---------------------------------------------------------------------
{ Copyright (C) 1983 - Perq Systems Corporation.
{---------------------------------------------------------------------}
module Except;
{-----------------------------------------------------------------------------
{
{ Except - Perq Pascal Exception Routines.
{ J. P. Strait   10 Dec 80.
{ Copyright (C) Three Rivers Computer Corporation, 1980, 1981, 1982, 1983.
{ 
{ Abstract:
{       Module Except provides the following things:
{
{       1) Definitions of the microcode generated exceptions.
{
{       2) A procedure to tell the microcode which segment number these
{          exceptions are defined in.
{
{       3) The default handler of all exceptions.  The compiler enables
{          this handler in every main program.
{
{       4) A Pascal routine to search the stack in when an exception is
{          raised.
{
{ Design:
{       The file Except.Dfs is included into Perq.Micro as well
{       as into this module.  It defines routine numbers for the exceptions
{       generated by the microcode.  Note that there must be agreement
{       between these constants and the routine numbers of the exception
{       definitions.  No program checks these--if you add or remove
{       exception definitions you must be sure to update Except.Dfs
{       in the appropriate way.
{
{       The routine number of RaiseP is also defined in Except.Dfs
{       as 0.  Since the microcode must know this, it is strongly
{       suggested that it not be modified.
{
{       The routine number of InitExceptions is not needed by the compiler
{       or Perq.Micro, but it has been assigned routine number 1 so that
{       its number will not change when new exceptions are defined.  This
{       means that new exceptions may be defined without requiring that the
{       operating system be re-linked.
{
{-----------------------------------------------------------------------------}

{-----------------------------------------------------------------------------
{ Change Log:
{
{ 13 Apr 83  V3.2  Brad Myers
{ Added BreakPoint exception.
{
{ 17 Feb 83  V3.1  David Golub
{ Define UnImplQCode exception.
{
{ 16 Nov 82  V3.0  Bill Braucher
{ Fixed names for 14-character compiler.
{
{ 28 Dec 81  V2.9  Michael R. Kristofic
{ Define RealDiv0 and Real2Int
{
{ 23 Dec 81  V2.8  Brad Myers
{ Fixed handler reraise bug
{
{ 20 Dec 81  V2.7  Michael R. Kristofic
{ Define  OverReal and UndeReal
{
{  3 Dec 81  V2.6  Brad Myers.
{ Export ExcSeg.
{ Make Handle All not handle Stack Overflow or SegFault.
{ }

{ 28 May 81  V2.5  Brad Myers.
{ Change name of STLate exception (so no conflict with Qcodes.dfs
{ }

{ 28 May 81  V2.4  John Strait.
{ Take out special test for InPmd (exception raised while in Scrounge).
{ This will be replaced by a handler of All exceptions in Scrounge.
{ }

{ 23 May 81  V2.3  John Strait.
{ Allow StackOverflow while in Scrounge (just like SegmentFault).
{ }

{ 18 May 81  V2.2  John Strait.
{ New exception for Long Integer overflow.
{ }

{ 12 May 81  V2.1  Brad A. Myers.
{ New IO imports.
{ }

{  5 May 81  V2.0  Brad A. Myers.
{ Added preliminary debugger.
{ }

{ 23 Mar 81  V1.2  J. P. Strait.
{ Add support for virtual memory.
{ }

{ 14 Mar 81  V1.1  J. P. Strait.
{ Add PMD and try to get it working.
{ }

{ 10 Dec 80  V1.0  J. P. Strait.
{ Start module as part of a proposal.
{ }
{-----------------------------------------------------------------------------}

exports


const ExceptVersion = '3.2';


procedure RaiseP( ES, ER, PStart, PEnd: Integer );
procedure InitExceptions;

exception Abort( Message: String );
exception Dump( Message: String );
exception XSegmentFault( S1,S2,S3,S4: Integer );  { segment fault }
exception XStackOverflow;                         { stack overflow }
exception DivZero;   { division by zero }
exception MulOvfl;   { overflow in multiplication }
exception StrIndx;   { string index out of range }
exception StrLong;   { string to be assigned is too long }
exception InxCase;   { array index or case expression out of range }
exception STLATETooDeep; { parameter in STLATE instruction is too large }
exception UndfQcd;   { execution of an undefined Q-code }
exception UndfInt;   { undefined device interrupt detected }
exception IOSFlt;    { segment fault detected during I/O }
exception MParity;   { memory parity error }
exception EStack;    { E-stack wasn't empty at INCDDS }
exception OvflLI;    { Overflow in conversion to integer from Long Integer }
exception OverReal;  { floating point overflow }
exception UndeReal;  { floating point underflow }
exception RealDiv0;  { floating point division by zero }
exception Real2Int;  { floating point real to integer overflow }
exception UnImplQCode; { QCode is defined, but not implemented in this
                         interpreter }
exception PasBreakPoint; { Pascal level breakpoint found.}

var ExcSeg: Integer;

private

{$R-  no range checks... we're gonna hack in the stack. }


   imports Memory from Memory;
   imports Virtual from Virtual;
   imports System from System;
   imports IO_Unit from IO_Unit;
   imports Code from Code;
   imports Scrounge from Scrounge;
   

const SetExcSeg = #220;
      {$Include ACB.Dfs}
      {$Include EEB.Dfs}
      {$Include Except.Dfs}
      {$Include RD.Dfs}
      {$Include VRD.Dfs}


procedure InitExceptions;
{-----------------------------------------------------------------------------
{
{ Abstract:
{       InitExceptions tells the microcode what segment number to use when
{       raising its own exceptions.  The segment number is the one that
{       the system assigns to this module.
{
{ Side affects:
{       ExcSeg is set to the current segment number.
{       The current segment is kept resident.
{
{-----------------------------------------------------------------------------}

begin { InitExceptions }
  InPmd := False;
  LoadExpr(SetExcSeg);
  InLineByte( 103 {STARTIO} );
  StorExpr(ExcSeg);
  IncRefCount(ExcSeg)   { ensure that this segment stays resident }
end { InitExceptions };


procedure RaiseP( ES, ER, PStart, PEnd: Integer );
{-----------------------------------------------------------------------------
{
{ Abstract:
{       RaiseP is called to raise an exception.  The compiler generates a
{       call to RaiseP in response to
{
{==============================
{
{            raise SomeException( original parameters )
{
{==============================
{
{       in the following way
{
{==============================
{            Push original parameters onto the MStack.
{
{            RAISE SegmentNumber(SomeException) RoutineNumber(SomeException)
{                  ParameterSize
{
{==============================
{            
{
{       The microcode calls RaiseP in the following way.
{
{==============================
{
{            Push parameters onto the MStack if appropriate.
{
{            ParameterSize := WordsOfParameters.
{
{            Error := ErrorNumber, Goto(CallRaise).
{
{==============================
{
{       Where CallRaise does the following.
{
{==============================
{
{            SaveTP := TP.
{
{            Push ExcSeg onto the MStack.
{
{            Push Error onto the MStack.
{
{            Push SaveTP-ParameterSize+1 onto the MStack.
{
{            Push SaveTP+1 onto the MStack.
{
{            call RaiseP.
{
{==============================
{
{ Parameters:
{       ER    - Routine number of the exception to be raised.
{       ES    - Segment number of the exception to be raised.
{       PStart- Pointer to the original parameters (as an offset from the
{               base of the stack).
{       PEnd  - Pointer to the first word after the original parameters
{               (as an offset from the base of the stack).
{
{ Calls:
{       Appropriate exception handler or HandleAll.
{
{ Design:
{       See the "PERQ QCode Reference Manual,  Q-Machine Architecture" for
{       a description of the format of exception enable blocks and the
{       format of variable routine descriptors.
{
{       RaiseP searches the exception enable list of each routine in the
{       dynamic chain.  When it finds one that matches ER and ES it
{       searches the dynamic chain again to see if the specified handler
{       is already active.  If it is active, RaiseP continues searching the
{       exception lists and dynamic chain where it left off.  This is done
{       in order to allow a handler to re-raise the same exception, and
{       to prevent unlimited recursion in an exception handler that has a
{       bug.
{
{       If an exception handler is found, the original parameters are
{       pushed onto the MStack and the handler is called with CALLV.
{
{       If no exception handler is found, HandleAll is called.
{
{
{       *** RaiseP may not contain any exception handlers.
{
{       *** RaiseP must be guaranteed to be resident.
{
{-----------------------------------------------------------------------------}

type StackArray = array[0..0] of Integer;
     pStackArray = ^StackArray;
var RaiseAP, AP1, AP2, AP3, EP, HR, HS, HGP, StackS: Integer;
    Stack: pStackArray;
    State: (ScanStack, ScanExceptionList, Found, FoundAll, NotFound);

  procedure HandleAll;
  {---------------------------------------------------------------------------
  {
  { Abstract:
  {       HandleAll is called when RaiseP is unable to find a handler for the
  {       exception that was raised.  HandleAll either performs some default
  {       action (e.g. increase stack segment size for ErrStackOverflow) or
  {       calls the debugger.
  {
  { Design:
  {       *** HandleAll may not contain any exception handlers.
  {
  {---------------------------------------------------------------------------}

  begin { HandleAll }
    if ES = ExcSeg then
      begin { check for special exceptions }
        if ER = ErrStackOverflow then
          begin
            InPmd := True;    { set InPmd at tense times like this }
            while IOInProgress do ;
            ChangeSize(StackSegment,
                       SAT^[StackSegment].Size +
                                          SIT^[StackSegment].Increment + 2);
            StartIO(SetStkLimit);
            InPmd := False
          end
        else
          if ER = ErrSegmentFault then
           SwapSegmentsIn(Stack^[PStart], Stack^[PStart+1], Stack^[PStart+2],
                          Stack^[PStart+3])
          else Scrounge(ES, ER, PStart, PEnd, ExcSeg, RaiseAP)
      end
    else Scrounge(ES, ER, PStart, PEnd, ExcSeg, RaiseAP)
  end { HandleAll };

begin { RaiseP }
  InLineByte( 99 {LSSN} );
  StorExpr(StackS);
  Stack := MakePtr(StackS,0,pStackArray);
  State := ScanStack;
  InLineByte( 244 {LDAP} );
  StorExpr(RaiseAP);
  Stack^[RaiseAP + ACBTL] := PStart - 1;  { fix the top link }
  AP1 := RaiseAP;
  repeat { scan the dynamic chain }
    HS := Stack^[AP1 + ACBRS];
    HGP := Stack^[AP1 + ACBGL];
    AP1 := Stack^[AP1 + ACBDL];  { follow the dynamic chain }
    if AP1 = 0 then { end of stack } State := NotFound
    else
      begin EP := Stack^[AP1 + ACBEP];
        State := ScanExceptionList;
        repeat { scan this routine's enable list }
          if EP = 0 then { end of list } State := ScanStack
          else
            begin
              if (Stack^[EP + EEBES] < 0) then {All handler}
                 begin
                 if (ES <> ExcSeg) or ((ER <> ErrSegmentFault) and
                                       (ER <> ErrStackOverflow))
                            then state := found;
                 end
              else begin
                   if ((Stack^[EP + EEBER] = ER) and
                       (Stack^[EP + EEBES] = ES)) then state := found;
                   end;
              if state = found then
                begin { handler found }
                  HR := Stack^[EP + EEBHR];
                  AP2 := RaiseAP;
                  AP3 := Stack^[AP2 + ACBDL];
                  while (AP2 <> AP1) { not at current ACB } and
                        ((Stack^[AP2 + ACBRR] <> HR) or
                         (Stack^[AP2 + ACBRS] <> HS) or
                         (Stack^[AP3 + ACBSL] <> AP1)) do
                    begin
                      AP2 := AP3;  { follow dynamic chain }
                      AP3 := Stack^[AP2 + ACBDL]
                    end;
                  if AP2 <> AP1 then {already active}
                      state := ScanExceptionList
                  else { not already active }
                    if Stack^[EP + EEBES] < 0 then State := FoundAll;
                end;
              if State = ScanExceptionList then { follow exception list }
                EP := Stack^[EP + EEBNE]
            end
        until State <> ScanExceptionList
      end
  until State <> ScanStack;
  if State in [Found, FoundAll] then
    begin
      if State = FoundAll then { push ER, ES, PEnd, PStart }
        begin LoadExpr(ES);
          InLineByte( 96 {MMS} );
          LoadExpr(ER);
          InLineByte( 96 {MMS} );
          LoadExpr(PStart);
          InLineByte( 96 {MMS} );
          LoadExpr(PEnd);
          InLineByte( 96 {MMS} )
        end
      else { push the original parameters onto the MStack }
        while PStart <> PEnd do
          begin LoadExpr(Stack^[PStart]);
            InLineByte( 96 {MMS} );
            PStart := PStart + 1
          end;
      { load the VRD }
      LoadExpr(AP1);
      LoadExpr(HR);
      LoadExpr(HGP);
      LoadExpr(HS);
      { call the handler }
      InLineByte( 187 {CALLV} )
    end
  else HandleAll
end { RaiseP }.
