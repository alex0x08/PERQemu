{---------------------------------------------------------------------
{ Copyright (C) 1983 - Perq Systems Corporation.
{---------------------------------------------------------------------}
module Writer;


{-----------------------------------------------------------------------------
{
{       Writer - Stream package output conversion routines.
{       J. P. Strait   ca. 1 Jan 81.
{       Copyright (C) Three Rivers Computer Corporation, 1981, 1982, 1983.
{
{ Abstract:
{       Writer is the character output module of the Stream package.  It
{       is called by code generated by the Pascal compiler in response to
{       a Write or Writeln.  It is one level above Module Stream and uses
{       Stream's output routines.
{
{-----------------------------------------------------------------------------}


{ 4 Jun 81  V2.2  John Strait.
{ Add Virgil headers and comments.
{ }

{ 19 May 81  V2.1  Brad Myers.
{ Turn off Range checking so printing of chArrays will work.
{ }

{ 12 May 81  V2.0  John Strait.
{ Use exceptions rather than StreamError.
{ }

exports


imports Stream from Stream;

 
 procedure WriteBoolean( var F: FileType; X: Boolean; Field: integer );
 procedure WriteCh( Var F: FileType; X: char; Field: integer );
 procedure WriteChArray( var F: FileType; var X: ChArray; Max, Field: integer );
 procedure WriteIdentifier( var F: FileType; X: integer; 
                            var IT: IdentTable; L, Field: integer );
 procedure WriteInteger( var F: FileType; X: integer; Field: integer );
 procedure WriteString( var F: FileType; var X: String; Field: integer );
 procedure WriteX( var F: FileType; X, Field, B: integer );


private

{$R-}

procedure WriteBoolean( var F: FileType; X: Boolean; Field: integer );
{-----------------------------------------------------------------------------
{
{ Abstract:
{       Writes a boolean in fixed format.
{
{ Parameters:
{       X - the boolean to be written.
{       F - the file into which X is to be written.
{       Field - the size of the field into which X is to be written.
{
{-----------------------------------------------------------------------------}

var I, W: integer;
begin { WriteBoolean }
 if ord(X) = ord(true) then W := 4 else W := 5;
 for I := W+1 to Field do
  begin F.Element.C := ' '; PutC(F) end;
 if Ord(X) = Ord(true) then
  begin
   F.Element.C := 'T'; PutC(F);
   F.Element.C := 'R'; PutC(F);
   F.Element.C := 'U'; PutC(F);
   F.Element.C := 'E'; PutC(F)
  end
 else
  if Ord(X) = Ord(false) then
   begin
    F.Element.C := 'F'; PutC(F);
    F.Element.C := 'A'; PutC(F);
    F.Element.C := 'L'; PutC(F);
    F.Element.C := 'S'; PutC(F);
    F.Element.C := 'E'; PutC(F)
   end
  else
   begin
    F.Element.C := 'U'; PutC(F);
    F.Element.C := 'N'; PutC(F);
    F.Element.C := 'D'; PutC(F);
    F.Element.C := 'E'; PutC(F);
    F.Element.C := 'F'; PutC(F)
   end
end { WriteBoolean };

procedure WriteCh( var F: FileType; X: char; Field: integer );
{-----------------------------------------------------------------------------
{
{ Abstract:
{       Writes a character in a fixed format.
{
{ Parameters:
{       X - the character to be written.
{       F - the file into which X is to be written.
{       Field - the size of the field into which X is to be written.
{
{-----------------------------------------------------------------------------}

begin { WriteCh }
 while Field > 1 do
  begin F.Element.C := ' '; PutC(F); Field := Field - 1 end;
 F.Element.C := X;
 PutC(F)
end { WriteCh };

procedure WriteChArray( var F: FileType; var X: ChArray; Max, Field: integer );
{-----------------------------------------------------------------------------
{
{ Abstract:
{       Writes a packed character array in fixed format.
{
{ Parameters:
{       X - the character array to be written.
{       F - the file into which X is to be written.
{       Field - the size of the field into which  X is to be written.
{       Max - the declared length of X.
{
{-----------------------------------------------------------------------------}

var I: integer;
begin { WriteChArray }
 if Field > Max then
  begin
   for I := Max+1 to Field do
    begin F.Element.C := ' '; PutC(F) end;
   Field := Max
  end;
 for I := 1 to Field do
  begin F.Element.C := X[I]; PutC(F) end
end { WriteChArray };

procedure WriteIdentifier( var F: FileType; X: integer; 
                           var IT: IdentTable; L, Field: integer );
{-----------------------------------------------------------------------------
{
{ Abstract:
{
{       Writes an identifier from a table in fixed format.
{
{ Parameters:
{
{       X - the ordinal of the identifier in the range 0 to L.
{       F - the file to which X is written.
{       IT  - the table of identifier names indexed from 0 to L.
{       L - the largest identifier ordinal defined by the table.
{       Field  -  the size of the field into which X is written.
{
{ Errors:
{       BadIdTable  if the length of the identifier table is less than 1.
{
{-----------------------------------------------------------------------------}

var Id: Identifier;
    I: integer;
begin { WriteIdentifier }
 if L <= 0 then raise BadIdTable(StreamName(F));
 if (X < 0) or (X > L) then
  begin
   for I := 6 to Field do
    begin F.Element.C := ' '; PutC(F) end;
   F.Element.C := 'U'; PutC(F);
   F.Element.C := 'N'; PutC(F);
   F.Element.C := 'D'; PutC(F);
   F.Element.C := 'E'; PutC(F);
   F.Element.C := 'F'; PutC(F)
  end
 else
  begin Id := IT[X];
   for I := Ord(Id[0])+1 to Field do
    begin F.Element.C := ' '; PutC(F) end;
   for I := 1 to Ord(Id[0]) do
    begin F.Element.C := Id[I]; PutC(F) end
  end
end { WriteIdentifier };

procedure WriteInteger( var F: FileType; X: integer; Field: integer );
{-----------------------------------------------------------------------------
{
{ Abstract:
{       Writes a decimal integer in fixed format.
{
{ Parameters:
{       X - the integer to be written.
{       F - the file into which X is to be written.
{       Field - the size of the field into which  X is to be written.
{
{-----------------------------------------------------------------------------}

const Smallest = #100000;    { smallest negative integer }
var D: array[1..6] of char;
    N, K: integer;
    Negative: boolean;
begin { WriteInteger }
 Negative := false;
 if X = Smallest then
  begin
   for N := Field downto 7 do 
    begin F.Element.C := ' '; PutC(F) end;
   F.Element.C := '-'; PutC(F);
   F.Element.C := '3'; PutC(F);
   F.Element.C := '2'; PutC(F);
   F.Element.C := '7'; PutC(F);
   F.Element.C := '6'; PutC(F);
   F.Element.C := '8'; PutC(F)
  end
 else
  begin N := 0;
   if X < 0 then
    begin Negative := true; X := -X end;
   repeat N := N + 1;
    D[N] := Chr(X mod 10 + Ord('0'));
    X := X div 10
   until X = 0;
   if Negative then
    begin N := N + 1; D[N] := '-' end;
   for K := N + 1 to Field do
    begin F.Element.C := ' '; PutC(F) end;
   for K := N downto 1 do
    begin F.Element.C := D[K]; PutC(F) end
  end
end { WriteInteger };

procedure WriteString( var F: FileType; var X: String; Field: integer );
{-----------------------------------------------------------------------------
{
{ Abstract:
{       Writes a string in fixed format.
{
{ Parameters:
{       X - the string to be written.
{       F - the file into which X is written.
{       Field - the size of the field into which X is written.
{
{-----------------------------------------------------------------------------}

var I: integer;
begin { WriteString }
 for I := Ord(X[0])+1 to Field do
  begin F.Element.C := ' '; PutC(F) end;
 for I := 1 to Ord(X[0]) do
  begin F.Element.C := X[I]; PutC(F) end
end { WriteString };

procedure WriteX( var F: FileType; X, Field, B: integer );
{-----------------------------------------------------------------------------
{
{ Abstract:
{       Writes an integer in fixed format with base B.
{
{ Parameters:
{       X - the integer to be written.
{       F - the file into which X is to be written.
{       Field - the size of the field into which  X is to be written.
{       B - the base of X.  It is an integer whose absolute value must
{           be between 2 and 36, inclusive.
{
{ Errors:
{       BadBase  if the base is not in 2..36.
{
{-----------------------------------------------------------------------------}

var Ch: char;
    D: array[1..17] of char;
    Negative: boolean;
    Lower, Upper, T, N, K: integer;
begin { WriteX }
 if not (Abs(B) in [2..36]) then raise BadBase(StreamName(F), B);
 Negative := false;
 if B < 0 then { write unsigned number } B := -B
 else { write signed number }
  if X < 0 then
   begin Negative := true; X := -X end;
 Upper := Shift(X,-8);
 Lower := X - Shift(Upper,8);
 N := 0;
 repeat N := N + 1;
  T := Upper mod B;
  Upper := Upper div B;
  T := Lower + Shift(T,8);
  Lower := T div B;
  K := T mod B;
  if K >= 10 then D[N] := Chr(K - 10 + Ord('A'))
  else D[N] := Chr(K + Ord('0'))
 until Upper + Lower = 0;
 if Negative then
  begin N := N + 1; D[N] := '-' end;
 for K := N + 1 to Field do
  begin F.Element.C := ' '; PutC(F) end;
 for K := N downto 1 do
  begin F.Element.C := D[K]; PutC(F) end
end { WriteX }.
