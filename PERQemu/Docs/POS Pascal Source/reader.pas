{---------------------------------------------------------------------
{ Copyright (C) 1983 - Perq Systems Corporation.
{---------------------------------------------------------------------}
module Reader;


{-----------------------------------------------------------------------------
{
{       Reader - Stream package input conversion routines.
{       J. P. Strait   ca. 1 Jan 81.
{       Copyright (C) Three Rivers Computer Corporation, 1981, 1982, 1983.
{ 
{ Abstract:
{       Reader is the character input module of the Stream package.  It is
{       called by code generated by the Pascal compiler in response to Read
{       or Readln.  It is one level above Module Stream and uses Stream's
{       lower-level input routines.
{
{-----------------------------------------------------------------------------}


{ 4 Jun 81  V2.1  John Strait.
{ Add Virgil headers and comments.
{ }

{ 12 May 81  V2.0  John Strait.
{ 1. Use exceptions rather than StreamError.
{ 2. Fix bug in read routines caused by not clearing CharReady.
{ }

exports
 

imports Stream from Stream;
 
 
 procedure ReadBoolean( var F: FileType; var X: boolean );
 procedure ReadCh( var F: FileType; var X: char; Field: integer );
 procedure ReadChArray( var F: FileType; var X: ChArray; Max, Len: integer );
 procedure ReadIdentifier( var F: FileType; var X: integer;
                           var IT: IdentTable; L: integer );
 procedure ReadInteger( var F: FileType; var X: integer );
 procedure ReadString( var F: FileType; var X: String; Max, Len: integer );
 procedure ReadX( var F: FileType; var X: integer; B: integer );


private

{$R-  shut off range checks }


const Tab = Chr(#11);
      FF = Chr(#14);

procedure ReadId( var F: FileType; var X: Identifier );
{-----------------------------------------------------------------------------
{
{ Abstract:
{       Reads an identifier (string of alphanumerics starting with alphabetic.
{
{ Parameters:
{       F - the file from which X is read.
{       X - set to an identifier.
{
{ Errors:
{       PastEof  if an attempt is made to read F past the Eof.
{       NotIdentifier  if a non-identifier is encountered in the file.
{
{-----------------------------------------------------------------------------}

var Ch: char;
    I: integer;
begin { ReadId }
 with F, Flag do
  begin
   if not CharReady then GetC(F);
   if FEof then raise PastEof(StreamName(F));
   while (Element.C in [' ', Tab, FF]) and not FEof do
    begin CharReady := False;
     GetC(F)
    end;
   if not FEof then
    begin
     if Element.C in ['a'..'z'] then
      Ch := Chr(Ord(Element.C) - Ord('a') + Ord('A'))
     else Ch := Element.C;
     if not (Ch in ['A'..'Z']) then raise NotIdentifier(StreamName(F));
     X[0] := Chr(IdentLength);
     I := 0;
     repeat
      if I < IdentLength then
       begin I := I + 1; X[I] := Ch end;
      CharReady := False;
      GetC(F);
      if Element.C in ['a'..'z'] then
       Ch := Chr(Ord(Element.C) - Ord('a') + Ord('A'))
      else Ch := Element.C
     until not (Ch in ['A'..'Z', '0'..'9']);
     X[0] := Chr(I)
    end
  end
end { ReadId };

procedure ReadBoolean( var F: FileType; var X: boolean );
{-----------------------------------------------------------------------------
{
{ Abstract:
{       Reads a boolean in free format.
{
{ Parameters:
{       X - the boolean to be read.
{       F - the file from which X is read.
{
{ Errors:
{       PastEof  if an attempt is made to read F past the Eof.
{       NotBoolean  if a non-boolean is encountered in the file.
{
{-----------------------------------------------------------------------------}

var Id, TId, FId: Identifier;
begin { ReadBoolean }
 ReadId(F,Id);
 if not F.Flag.FEof then
  begin TId := 'TRUE';
   FId := 'FALSE';
   if Id[0] < TId[0] then TId[0] := Id[0];
   if Id[0] < FId[0] then FId[0] := Id[0];
   if Id = TId then X := true
   else
    if Id = FId then X := false
    else raise NotBoolean(StreamName(F))
  end
end { ReadBoolean };

procedure ReadCh( var F: FileType; var X: char; Field: integer );
{-----------------------------------------------------------------------------
{
{ Abstract:
{       Reads a character in fixed or free format.
{
{ Parameters:
{       X - the character to be read.
{       F - the file from which X is to be read.
{       Field - the size of the field X is in.
{
{ Errors:
{       PastEof  if an attempt is made to read F past the Eof.
{
{-----------------------------------------------------------------------------}

begin { ReadCh }
 with F, Flag do
  begin
   if not CharReady then GetC(F);
   if FEof then raise PastEof(StreamName(F));
   while (Field > 1) and not FEoln do
    begin CharReady := False;
     GetC(F);
     Field := Field - 1
    end;
   X := F.Element.C;
   if not FEoln then CharReady := false
  end
end { ReadCh };

procedure ReadChArray( var F: FileType; var X: ChArray; Max, Len: integer );
{-----------------------------------------------------------------------------
{
{ Abstract:
{       Reads a packed character array in free or fixed format.   If free
{       format reading is selected, spaces are skipped and characters are
{       read until another space is encountered.
{
{ Parameters:
{       X - the character array to be read.
{       F - the file from which X is to be read.
{       Max - the declared length of X.
{       Len - the size of the field.  Len <= 0 selects free format reading.
{
{ Errors:
{       PastEof  if an attempt is made to read F past the Eof.
{
{-----------------------------------------------------------------------------}

var I, L: integer;
begin { ReadChArray }
 with F, Flag do
  begin
   if not CharReady then GetC(F);
   if FEof then raise PastEof(StreamName(F));
   I := 0;
   if Len >= 0 then
    begin
     if Len > Max then L := Max else L := Len;
     while (I < L) and not (FEof or FEoln) do
      begin I := I + 1;
       X[I] := Element.C;
       CharReady := False;
       GetC(F)
      end;
     L := I;
     if L < Max then
      for I := L+1 to Max do X[I] := ' ';
     if not (FEof or FEoln) then
      for I := L+1 to Len do
       begin CharReady := False;
        GetC(F)
       end
    end
   else
    begin
     while (Element.C in [' ', Tab, FF]) and not FEof do
      begin CharReady := False;
       GetC(F)
      end;
     if not FEof then
      begin
       while Element.C <> ' ' do
        begin I := I + 1;
         if I <= Max then X[I] := Element.C;
         CharReady := False;
         GetC(F)
        end;
       L := I;
       if L < Max then
        for I := L+1 to Max do X[I] := ' '
      end
    end
  end
end { ReadChArray };

procedure ReadIdentifier( var F: FileType; var X: integer;
                          var IT: IdentTable; L: integer );
{-----------------------------------------------------------------------------
{
{ Abstract:
{       Reads an identifier and returns its position in a table.  A table
{       lookup is performed requiring only that the identifier typed
{       uniquely matches the beginning of a single table entry.
{
{ Parameters:
{       X - set to the ordinal of the identifier read.
{       F - the file from which X is read.
{       IT - the table of identifiers indexed from 0 to L.
{       L - the largest identifier ordinal defined by the table.
{
{ Errors:
{       BadIdTable  if length of the identifier table is less than 1.
{       PastEof  if an attempt is made to read F past the Eof.
{       NotIdentifier  if a non-identifier is encountered in the file.
{       IdNotDefined  if the identifier is not in the table.
{       IdNotUnique  if the identifier is not unique.
{
{-----------------------------------------------------------------------------}

var Id, N: Identifier;
    I, J, Exact, Unique: integer;
begin { ReadIdentifier }
 if L <= 0 then raise BadIdTable(StreamName(F));
 ReadId(F,Id);
 if not F.Flag.FEof then
  begin Exact := -1;
   Unique := -1;
   for I := 0 to L do
    begin N := IT[I];
     for J := 1 to Ord(N[0]) do
      if N[J] in ['a'..'z'] then
       N[J] := Chr(Ord(N[J]) - Ord('a') + Ord('A'));
     if Id = N then { exact match }
      if Exact >= 0 then Exact := L + 1
      else Exact := I
     else
      if Exact < 0 then
       begin
        if Id[0] < N[0] then N[0] := Id[0];
        if Id = N then
         if Unique >= 0 then Unique := L + 1
         else Unique := I
       end
     end;
    if Exact > L then raise IdNotUnique(StreamName(F),Id)
    else
     if Exact >= 0 then X := Exact
     else
      if Unique > L then raise IdNotUnique(StreamName(F),Id)
      else
       if Unique >= 0 then X := Unique
       else raise IdNotDefined(StreamName(F),Id)
  end
end { ReadIdentifier };

procedure ReadInteger( var F: FileType; var X: integer );
{-----------------------------------------------------------------------------
{
{ Abstract:
{       Reads a decimal integer in free format.
{
{ Parameters:
{       X - the integer to be read.
{       F - the file from which X is to be read.
{
{ Errors:
{       PastEof  if an attempt is made to read F past the Eof.
{       NotNumber  if non-numeric input is encountered in the file.
{       LargeNumber  if the number is not in the range -32768..32767.
{
{-----------------------------------------------------------------------------}

const Mdiv10 = 3276;    { maximum integer  div  10 }
      MPmod10 = 7;      { maximum positive integer  mod  10 }
      MNmod10 = 8;      { maximum negative integer  mod  10 }
var I, D, Mmod10: integer;
    Negative, Large: boolean;
begin { ReadInteger }
 with F, Flag do
  begin
   if not CharReady then GetC(F);
   if FEof then raise PastEof(StreamName(F));
   while (Element.C in [' ', Tab, FF]) and not FEof do
    begin CharReady := False;
     GetC(F)
    end;
   if not FEof then
    begin Large := false;
     if Element.C in ['+', '-'] then
      begin Negative := Element.C = '-';
       CharReady := False;
       GetC(F)
      end
     else Negative := false;
     if Negative then Mmod10 := MNmod10 else Mmod10 := MPmod10;
     I := 0;
     if not (Element.C in ['0'..'9']) then raise NotNumber(StreamName(F));
     repeat D := Ord(Element.C) - Ord('0');
      CharReady := False;
      GetC(F);
      Large := Large or (I > Mdiv10) or
               ((I = Mdiv10) and (D > Mmod10));
      I := I * 10 + D
     until not (Element.C in ['0'..'9']);
     if Large then raise LargeNumber(StreamName(F))
     else
      if Negative then X := -I
      else X := I
    end
  end
end { ReadInteger };

procedure ReadString( var F: FileType; var X: String; Max, Len: integer );
{-----------------------------------------------------------------------------
{
{ Abstract:
{       Reads a string in free or fixed format.  If free format is selected,
{       spaces are skipped and characters are read until another space is
{       encountered.
{
{ Parameters:
{       X - the string to be read.
{       F - the file from which X is to be read.
{       Max - the declared maximum length of the string.
{       Len - the size of the field.  Len <= 0 selects free format.
{
{ Errors:
{       PastEof  if an attempt is made to read F past the Eof.
{
{-----------------------------------------------------------------------------}

var I, L: integer;
begin { ReadString }
 with F, Flag do
  begin
   if not CharReady then GetC(F);
   if FEof then raise PastEof(StreamName(F));
   X[0] := Chr(Max);
   I := 0;
   if Len >= 0 then
    begin
     if Len > Max then L := Max else L := Len;
     while (I < L) and not (FEof or FEoln) do
      begin I := I + 1;
       X[I] := Element.C;
       CharReady := False;
       GetC(F)
      end;
     X[0] := Chr(I);
     if not (FEof or FEoln) then
      L := I;
      for I := L+1 to Len do
       begin CharReady := False;
        GetC(F)
       end
    end
   else
    begin
     while (Element.C in [' ', Tab, FF]) and not FEof do
      begin CharReady := False;
       GetC(F)
      end;
     if not FEof then
      begin
       while Element.C <> ' ' do
        begin
         if I < Max then
          begin I := I + 1; X[I] := Element.C end;
         CharReady := False;
         GetC(F)
        end;
       X[0] := Chr(I)
      end
    end
  end
end { ReadString };

procedure ReadX( var F: FileType; var X: integer; B: integer );
{-----------------------------------------------------------------------------
{
{ Abstract:
{       Reads an integer in free format with base B.   B may be any integer
{       between 2 and 36, inclusive.
{
{ Parameters:
{       X - the integer to be read.
{       F - the file from which X is to be read.
{       Field - the size of the field X is in.
{       B - the base of X.   It may be any integer between 2 and 36, inclusive.
{
{ Errors:
{       PastEof  if an attempt is made to read F past the Eof.
{       NotNumber  if non-numeric input is encountered in the file.
{       LargeNumber  if the number is not in the range -32768..32767.
{       BadBase  if the base is not in 2..36.
{
{-----------------------------------------------------------------------------}

var Ch: char;
    S: (Unsigned, Negative, Positive);
    C: set of '0'..'Z';
    Large: boolean;
    Lower, Upper, T: integer;
begin { ReadX }
 if not (B in [2..36]) then raise BadBase(StreamName(F), B);
 with F, Flag do
  begin
   if not CharReady then GetC(F);
   if FEof then raise PastEof(StreamName(F));
   while (Element.C in [' ', Tab, FF]) and not FEof do
    begin CharReady := False;
     GetC(F)
    end;
   if not FEof then
    begin Large := false;
     if Element.C = '+' then
      begin S := Positive;
       CharReady := False;
       GetC(F)
      end
     else
      if Element.C = '-' then
       begin S := Negative;
        CharReady := False;
        GetC(F)
       end
      else S := Unsigned;
     if B < 10 then C := ['0'..Chr(B + Ord('0'))]
     else C := ['0'..'9', 'A'..Chr(B - 10 + Ord('A'))];
     if Element.C in ['a'..'z'] then
      Ch := Chr(Ord(Element.C) - Ord('a') + Ord('A'))
     else Ch := Element.C;
     if not (Ch in C) then raise NotNumber(StreamName(F));
     Upper := 0;
     Lower := 0;
     repeat CharReady := False;
      GetC(F);
      if Ch in ['0'..'9'] then T := Ord(Ch) - Ord('0')
      else T := Ord(Ch) - Ord('A') + 10;
      Lower := Lower * B + T;
      T := Shift(Lower,-8);
      Lower := LAnd(Lower,#377);
      Upper := Upper * B + T;
      case S of
       Unsigned: Large := Large or (Upper > 255);
       Positive: Large := Large or (Upper > 127);
       Negative: Large := Large or (Upper > 128) or
                          (Upper = 128) and (Lower > 0)
       end;
      if Element.C in ['a'..'z'] then
       Ch := Chr(Ord(Element.C) - Ord('a') + Ord('A'))
      else Ch := Element.C
     until not (Ch in C);
     if Large then raise LargeNumber(StreamName(F));
     X := Shift(Upper,8) + Lower;
     if S = Negative then X := -X
    end
  end
end { ReadX }.
